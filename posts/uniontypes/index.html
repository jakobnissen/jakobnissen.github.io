<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/basic.css"> <link rel=icon  href="/assets/v.svg"> <title>Union vs sum types</title> <header> <div class=blog-name ><a href="/">viralinstruction</a></div> <nav> <ul> <li><a href="/">Home</a> <li><a href="/about/">About</a> <li><a href="/feed.xml">RSS</a> </ul> <img src="/assets/hamburger.svg" id=menu-icon > </nav> </header> <div class=franklin-content ><h1 id=union_vs_sum_types ><a href="#union_vs_sum_types" class=header-anchor >Union vs sum types</a></h1> <p><em>Written 2021-10-06</em></p> <p>Union types and sum types are programming language concepts that have been around for decades, but I think they&#39;re getting more popular these years. The two concepts are closely related but their subtle differences impacts their relative strengths. This post is an explanation of the concepts and a list of pros and cons of the two.</p> <h2 id=structs_are_product_types ><a href="#structs_are_product_types" class=header-anchor >Structs are &quot;product types&quot;</a></h2> <p>Union types, sum types and product types are all <em>algebraic data types</em>, which sound super complicated, but the basic concept is actually really simple.</p> <p>Let&#39;s begin somewhere familiar: With an ordinary struct. A database used by my job contains &quot;cases&quot; who are known by identifiers like this</p> <div class=plaintext ><pre><code class="julia hljs"><span class=hljs-keyword >struct</span> CaseID_V2 {
    year: u16,
    number: u32
}</code></pre></div> <p>This definition creates a new type <code>CaseID_V2</code>. We can think of a struct like an AND operator: <code>CaseID_V2</code> is a new type that is composed of a <code>u16</code> AND a <code>u32</code>.</p> <p>What is <em>type</em>, actually?</p> <p>Well, one can think about types as sets of possible values. Here for <code>u16</code>:</p> <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mn>16</mn><mo>=</mo><mo stretchy=false >{</mo><mn>0</mn><mi>x</mi><mn>0000</mn><mo separator=true >,</mo><mn>0</mn><mi>x</mi><mn>0001</mn><mo separator=true >,</mo><mn>0</mn><mi>x</mi><mn>0002...0</mn><mi>x</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mo stretchy=false >}</mo></mrow><annotation encoding="application/x-tex">u16 = \{ 0x0000, 0x0001, 0x0002 ... 0xffff \}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">u</span><span class=mord >16</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >{</span><span class=mord >0</span><span class="mord mathnormal">x</span><span class=mord >0000</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >0</span><span class="mord mathnormal">x</span><span class=mord >0001</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >0</span><span class="mord mathnormal">x</span><span class=mord >0002...0</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.10764em;">ffff</span><span class=mclose >}</span></span></span></span> <p>What values of <code>CaseID_V2</code> are there? Well, if a <code>CaseID_V2</code> is a <code>u16</code> and a <code>u32</code>, then the set of possible <code>CaseID_V2</code> is simply the Cartesian product of the two types &#40;e.g. all possible combinations of the two, denoted by <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.66666em;vertical-align:-0.08333em;"></span><span class=mord >×</span></span></span></span>&#41;:</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>C</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>I</mi><msub><mi>D</mi><mrow><mi>V</mi><mn>2</mn></mrow></msub><mo>=</mo><mi>u</mi><mn>16</mn><mo>×</mo><mi>u</mi><mn>32</mn></mrow><annotation encoding="application/x-tex">CaseID_{V2} = u16 \times u32</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">a</span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span><span class="mord mtight">2</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">u</span><span class=mord >16</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">u</span><span class=mord >32</span></span></span></span></span> <p>And ta-da&#33; That&#39;s why structs are called product types. That&#39;s really all there is to it.</p> <h2 id=union_types ><a href="#union_types" class=header-anchor >Union types</a></h2> <p>Sometimes though, we want a new type which is not composed of one field AND another, but instead one field OR another. The same database at my work actually changed its <code>CaseID</code> in 2021, for some reason, hence the <code>_V2</code> suffix in the previous example. The old definition looked like this:</p> <div class=plaintext ><pre><code class="julia hljs"><span class=hljs-keyword >struct</span> CaseID_V1 {
    numbers: u32,
    letters: u32 // encoded <span class=hljs-keyword >in</span> base36
}</code></pre></div> <p>Now, any data type that contains a case ID must be able to have a notion of containing EITHER a <code>CaseID_V1</code> OR a <code>CaseID_V2</code>. We call such an either/or type a <em>union type</em>.</p> <p>In pseudocode, it could look like:</p> <div class=plaintext ><pre><code class="julia hljs">union type CaseID {
    CaseID_V1,
    CaseID_V2
}</code></pre></div> <p>And we can then put <em>that</em> into a struct, if we want:</p> <div class=plaintext ><pre><code class="julia hljs"><span class=hljs-keyword >struct</span> Case {
    id: CaseID,
    creation: Date,
    [ etc. ]
}</code></pre></div> <p>Why do we call it a union type? Well, similar to reason we call struct product types. The possible values in the new union type is the <em>union</em> of its members:</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>C</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>I</mi><mi>D</mi><mo>=</mo><mi>C</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>I</mi><msub><mi>D</mi><mrow><mi>V</mi><mn>1</mn></mrow></msub><mo>∪</mo><mi>C</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>I</mi><msub><mi>D</mi><mrow><mi>V</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">CaseID = CaseID_{V1} \cup CaseID_{V2}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">a</span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">a</span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >∪</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">a</span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span><span class="mord mtight">2</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> <p>Since its values are either <code>CaseID_V1</code> or <code>CaseID_V2</code>, clearly the set of possible values are just all the values that are in either set, or equivalently the union of the two sets.</p> <h2 id=union_types_is_good_for_set_operations ><a href="#union_types_is_good_for_set_operations" class=header-anchor >Union types is good for set operations</a></h2> <p>Here&#39;s a dilemma, though: What if we do this?</p> <div class=plaintext ><pre><code class="julia hljs">union type MyType {
    bool,
    bool
}</code></pre></div> <p>This says that <code>MyType</code> is EITHER a <code>bool</code> OR a... <code>bool</code>? How many possible values is this?</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>M</mi><mi>y</mi><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi><mo>=</mo><mo stretchy=false >{</mo><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo separator=true >,</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo stretchy=false >}</mo><mo>∪</mo><mo stretchy=false >{</mo><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo separator=true >,</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo stretchy=false >}</mo><mo>=</mo><mo stretchy=false >{</mo><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo separator=true >,</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo stretchy=false >}</mo><mo>=</mo><mi>b</mi><mi>o</mi><mi>o</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">MyType = \{false, true\} \cup \{false, true\} = \{false, true\} = bool</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >{</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class=mclose >}</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >∪</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >{</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class=mclose >}</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >{</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class=mclose >}</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">oo</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span></span> <p>It&#39;s still just the set <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >{</mo><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo separator=true >,</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo stretchy=false >}</mo></mrow><annotation encoding="application/x-tex">\{false, true\}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >{</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class=mclose >}</span></span></span></span>&#33; In other words, <code>MyType</code> is equivalent to <code>bool</code>. Or one might even say it <em>is</em> <code>bool</code>.</p> <p>That simplification is pretty neat, because it allows us to express uncertainty about types as union types, and do set operations on those. For example, suppose you have functions <code>f</code>, which returns the union <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo><mo>=</mo><mi>u</mi><mn>16</mn><mo>∪</mo><mi>i</mi><mn>16</mn></mrow><annotation encoding="application/x-tex">f(x) = u16 \cup i16</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">u</span><span class=mord >16</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >∪</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class=mord >16</span></span></span></span>, and <code>g</code> which returns <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo><mo>=</mo><mi>u</mi><mn>16</mn><mo>∪</mo><mi>u</mi><mn>32</mn></mrow><annotation encoding="application/x-tex">g(x) = u16 \cup u32</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">u</span><span class=mord >16</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >∪</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">u</span><span class=mord >32</span></span></span></span> for four possible types total. If you now call either <code>f</code> OR <code>g</code>, what are your possible return types?</p> <p>It&#39;s simply <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo><mo>∪</mo><mi>g</mi><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo><mo>=</mo><mi>u</mi><mn>16</mn><mo>∪</mo><mi>i</mi><mn>16</mn><mo>∪</mo><mi>u</mi><mn>32</mn></mrow><annotation encoding="application/x-tex">f(x) \cup g(x) = u16 \cup i16 \cup u32</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >∪</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">u</span><span class=mord >16</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >∪</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class=mord >16</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >∪</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">u</span><span class=mord >32</span></span></span></span>, &quot;deduplicated&quot; to just three types.</p> <p>A similar simplification happens if you union two types where one is a superset of the other. For example, suppose your language has a type <code>uint</code>, which just means &quot;any unsigned integer&quot;, no matter its width. In that case <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mn>16</mn><mo>∪</mo><mi>u</mi><mi>i</mi><mi>n</mi><mi>t</mi><mo>=</mo><mi>u</mi><mi>i</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">u16 \cup uint = uint</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">u</span><span class=mord >16</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >∪</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span></span></span></span> - after all, the set of values <code>uint</code><em>contains</em> the set <code>u16</code>.</p> <h2 id=sum_types ><a href="#sum_types" class=header-anchor >Sum types</a></h2> <p>Sometimes when you program, you don&#39;t necessarily want that deduplication. Suppose you want to make a union type that contains <em>either</em> the year of the Gregorian calendar &#40;stored in a <code>u16</code>&#41;, or the year according to the Hijri calendar &#40;also stored in a <code>u16</code>&#41;. You can&#39;t express this as a union type <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mi>u</mi><mn>16</mn><mo>∪</mo><mi>u</mi><mn>16</mn><mo>=</mo><mi>u</mi><mn>16</mn></mrow><annotation encoding="application/x-tex">T = u16 \cup u16 = u16</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">u</span><span class=mord >16</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >∪</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">u</span><span class=mord >16</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">u</span><span class=mord >16</span></span></span></span>, because in your case, these two <code>u16</code> are <em>different things</em>, that just happen to have the same representation, but shouldn&#39;t be conflated.</p> <p>The solution is pretty straightforward: You create two new types that wrap the <code>u16</code>s, and serve as a &quot;type tag&quot; so the program knows how to interpret the data. Something like:</p> <div class=plaintext ><pre><code class="julia hljs"><span class=hljs-keyword >struct</span> Year_Gregorian {
    val: u16
}

<span class=hljs-keyword >struct</span> Year_Hijri {
    val: u16
}

union type Year {
    Year_Gregorian,
    Year_Hijri
}</code></pre></div> <p>This kind of type - a union type with each member tagged - is called a <em>tagged union</em>. It&#39;s also called a <em>sum type</em>. By now you can guess why it&#39;s called a sum type: The number of values of type <code>Year</code> is exactly the sum of its members: <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >∣</mi><mi>Y</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi mathvariant=normal >∣</mi><mo>=</mo><mi mathvariant=normal >∣</mi><mi>Y</mi><mi>e</mi><mi>a</mi><msub><mi>r</mi><mrow><mi>G</mi><mi>r</mi><mi>e</mi><mi>g</mi><mi>o</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi></mrow></msub><mi mathvariant=normal >∣</mi><mo>+</mo><mi mathvariant=normal >∣</mi><mi>Y</mi><mi>e</mi><mi>a</mi><msub><mi>r</mi><mrow><mi>H</mi><mi>i</mi><mi>j</mi><mi>r</mi><mi>i</mi></mrow></msub><mi mathvariant=normal >∣</mi></mrow><annotation encoding="application/x-tex">|Year| = |Year_{Gregorian}| + |Year_{Hijri}|</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class=mord >∣</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1.036108em;vertical-align:-0.286108em;"></span><span class=mord >∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">G</span><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">or</span><span class="mord mathnormal mtight">ian</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.286108em;"><span></span></span></span></span></span></span><span class=mord >∣</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1.036108em;vertical-align:-0.286108em;"></span><span class=mord >∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.08125em;">H</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.286108em;"><span></span></span></span></span></span></span><span class=mord >∣</span></span></span></span>.</p> <p>Sum types are really useful when you want to be 100&#37; sure you can distinguish all members of your union. </p> <h2 id=sum_types_in_rust ><a href="#sum_types_in_rust" class=header-anchor >Sum types in Rust</a></h2> <p>Rust calls sum types &quot;enums&quot; &#40;a slight misnomer&#41;. You can make pretty complicated sum types very easily:</p> <div class=rustcode ><pre><code class="julia hljs">enum ComplicatedEnum {
    IsEmpty,
    Color(u8, u8, u8),
    Name { given: <span class=hljs-built_in >String</span>, sur: <span class=hljs-built_in >String</span> }
}</code></pre></div> <p>One interesting catch about Rust&#39;s enums is this: Instead of defining three ordinary types <code>IsEmpty</code>, <code>Color</code> and <code>Name</code>, these three &quot;variants&quot; can only exist as part of an <code>ComplicatedEnum</code> and not on their own. This implies that no value can have the type <code>IsEmpty</code>: All values of <code>ComplicatedEnum</code> is just of the type <code>ComplicatedEnum</code>.</p> <p>I don&#39;t think there is any big theoretical reason for this &quot;forced wrapping&quot; of sum types in Rust, but it has important implications for practical use of Rust&#39;s sum types, which I&#39;ll get to in a bit.</p> <h2 id=union_types_in_julia ><a href="#union_types_in_julia" class=header-anchor >Union types in Julia</a></h2> <p>In Julia, types matches perfectly well with the idea of &quot;types as sets of values&quot;:</p> <div class=juliacode ><pre><code class="julia hljs">julia&gt; <span class=hljs-number >5</span> <span class=hljs-keyword >isa</span> <span class=hljs-built_in >Int</span> <span class=hljs-comment ># check if 5 is an instance of Int</span>
<span class=hljs-literal >true</span>

julia&gt; <span class=hljs-number >5</span> <span class=hljs-keyword >isa</span> <span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Int</span>, <span class=hljs-built_in >String</span>}
<span class=hljs-literal >true</span>

julia&gt; <span class=hljs-number >5</span> <span class=hljs-keyword >isa</span> <span class=hljs-built_in >Integer</span> <span class=hljs-comment ># Integer is a superset of Int</span>
<span class=hljs-literal >true</span>

julia&gt; <span class=hljs-number >5</span> <span class=hljs-keyword >isa</span> <span class=hljs-built_in >Union</span>{<span class=hljs-built_in >String</span>, <span class=hljs-built_in >Set</span>, <span class=hljs-built_in >Char</span>}
<span class=hljs-literal >false</span>

julia&gt; <span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Int</span>, <span class=hljs-built_in >Integer</span>, <span class=hljs-built_in >Char</span>, <span class=hljs-built_in >UInt</span>, <span class=hljs-built_in >Int</span>} <span class=hljs-comment ># deduplication</span>
<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Char</span>, <span class=hljs-built_in >Integer</span>}</code></pre></div> <p>In short, the value <code>5</code> belongs to both the types <code>Int</code>, <code>Union&#123;Int, String&#125;</code>, <code>Integer</code>, and an infinite number of other types.</p> <p>Another difference from Rust is Julia is a dynamic language. Briefly, in static languages, expressions &#40;e.g. code&#41; has types, but types don&#39;t really exist at runtime since they are optimized away and everything is just a binary blob. In dynamic languages, values have types at runtime, and whatever type the compiler infer before runtime is immaterial: It has no impact on what values or types are actually produced at runtime.</p> <p>What this means is that, even if the compiler infers some value <code>x</code> to be of type <code>Union&#123;A, B, C&#125;</code>, at runtime, the type of <code>x</code> will be just <code>A</code>, <code>B</code> or <code>C</code>. Union types don&#39;t exist at runtime. They are only used to express the compiler&#39;s uncertainty about what is going to happen when the program runs.</p> <h2 id=advantages_of_julias_union_types_over_rusts_sum_types ><a href="#advantages_of_julias_union_types_over_rusts_sum_types" class=header-anchor >Advantages of Julia&#39;s union types over Rust&#39;s sum types</a></h2> <p>Many of the differences between Julia&#39;s and Rust&#39;s types actually come from the &quot;forced wrapping&quot; of Rust&#39;s sum types, not necessarily from the fact they are sum types instead of union types.</p> <h4 id=backwards_compatible_changes ><a href="#backwards_compatible_changes" class=header-anchor >Backwards compatible changes</a></h4> <p>If you have an API that expects to be supplied with a <code>A</code>, then you can always change it to take a <code>Union&#123;A, B&#125;</code> without breakage, because all values of type <code>A</code> are also values of type <code>Union&#123;A, B&#125;</code>.</p> <p>Similarly, if your function returns a <code>Union&#123;A, B&#125;</code>, you can change it to just return <code>A</code> without breakage.</p> <p>This won&#39;t work in Rust: You can&#39;t change a function that took an <code>Option&lt;usize&gt;</code> to take a <code>usize</code> without breaking user&#39;s code, nor can you return <code>usize</code> where you previously returned <code>Option&lt;usize&gt;</code>.</p> <h4 id=no_need_to_wrap_and_unwrap_sum_types ><a href="#no_need_to_wrap_and_unwrap_sum_types" class=header-anchor >No need to wrap and unwrap sum types</a></h4> <p>In Rust, you can&#39;t access the variants of a sum type directly because they are always wrapped. This leads to a <em>lot</em> of boilerplate: Check the long list of methods for <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a> and <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> which exist just for unwrapping and re-wrapping these types in various circumstances.</p> <p>With Julia&#39;s system it&#39;s much easier: You don&#39;t unwrap and re-wrap because it&#39;s not wrapped in the first place. How do you add 1 to <code>x</code> if it&#39;s a <code>Union&#123;Int, UInt&#125;</code>? Just <code>x &#43; 1</code>, like any normal integer.</p> <h4 id=more_possibilities_for_compiler_optimization ><a href="#more_possibilities_for_compiler_optimization" class=header-anchor >More possibilities for compiler optimization</a></h4> <p>Just like it&#39;s not a breaking change to return a narrower union type or accept a broader one, it&#39;s also an allowed compiler change.</p> <p>Suppose you write a function <code>f</code> that returns <code>Union&#123;A, B&#125;</code> and you pass it into a function <code>g</code> expecting that. But now, in some code, you call <code>f</code> with one of the argument as a constant. The compiler will then check if that constant argument narrows down the return type of <code>f</code>. Let&#39;s say with the constant folded argument <code>f</code> is guaranteed to return <code>A</code>. If so, the compiler will then know <code>g</code> will be getting an <code>A</code>, not a <code>Union&#123;A, B&#125;</code> - so now <code>g</code> can be further optimized, for example by compiling away all branches that occur if the input is a <code>B</code>.</p> <h2 id=advantages_of_rusts_sum_types_over_julias_union_types ><a href="#advantages_of_rusts_sum_types_over_julias_union_types" class=header-anchor >Advantages of Rust&#39;s sum types over Julia&#39;s union types</a></h2> <h4 id=unwrapping_forces_you_to_remember_youre_dealing_with_a_sum_type ><a href="#unwrapping_forces_you_to_remember_youre_dealing_with_a_sum_type" class=header-anchor >Unwrapping forces you to remember you&#39;re dealing with a sum type</a></h4> <p>Julia&#39;s union types may have less boilerplate because you can use them as if they were concrete types - but that&#39;s also a dangerous trap.</p> <p>Consider the Julia function <code>findfirst</code>, which returns <code>Union&#123;Int, Nothing&#125;</code> versus Rust&#39;s <code>iter.position</code>, returning <code>Option&lt;usize&gt;</code>: It&#39;s easy to forget <code>findfirst</code> can return nothing and not handle that case, introducing a bug. But it&#39;s not possible to mistaken an <code>Option&lt;usize&gt;</code> for a <code>usize</code>, because they&#39;re incompatible types and you <em>must</em> unwrap the sum type.</p> <h4 id=wrapped_types_are_more_straightforward_and_therefore_explicit ><a href="#wrapped_types_are_more_straightforward_and_therefore_explicit" class=header-anchor >Wrapped types are more straightforward and therefore explicit</a></h4> <p>The intricate set operations possible with union types can also be pretty annoying when you&#39;re just trying to code. For example, suppose <code>f</code> is a function returning type <code>T</code>. What&#39;s the return type of this Rust code?</p> <div class=rustcode ><pre><code class="julia hljs">vec![f()]</code></pre></div>
<p>Yep, it&#39;s <code>Vec&lt;T&gt;</code>. Now what&#39;s the return type of this Julia code?</p>
<div class=juliacode ><pre><code class="julia hljs">[f()]</code></pre></div>
<p><code>Vector&#123;T&#125;</code>, obviously&#33; Right? Nope, not necessarily:</p>
<div class=juliacode ><pre><code class="julia hljs">julia&gt; f() = rand(<span class=hljs-built_in >Bool</span>) ? <span class=hljs-number >1</span> : <span class=hljs-literal >nothing</span>;

julia&gt; g() = [f()];

julia&gt; only(Core.Compiler.return_types(g, ()))
<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int64</span>}, <span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Nothing</span>}}</code></pre></div>
<p>Instead of a vector of unions, its a union of vectors. This must necessarily be true when you think about it, but it&#39;s just one of these examples where union types can &quot;pull the rug&quot; under you by suddenly doing something clever.</p>
<h4 id=no_compiler_optimizations_mean_no_compiler_costs ><a href="#no_compiler_optimizations_mean_no_compiler_costs" class=header-anchor >No compiler optimizations mean no compiler costs</a></h4>
<p>The Julia compiler optimizations mentioned above enabled by automatic restriction of union types are cute. But what if you have a union composed of, say 10 variants? If your language compiles specialized functions for every input type &#40;&quot;monomorphization&quot;&#41;, as Julia and Rust does, this can cause an combinatorial explosion which leads to huge compilation times and bloated code. In fact, in Julia, this gets so bad that the compiler just gives up and emits code that checks the type at runtime if it infers that a value is a union with more than 4 members.</p>
<p>In this case, simply checking which variant you have with if/else statements is much more efficient than clever compiler tricks. Or even better than if/else statements...</p>
<h4 id=exhaustive_pattern_matching ><a href="#exhaustive_pattern_matching" class=header-anchor >Exhaustive pattern matching</a></h4>
<p>Precisely because Rust&#39;s sum types don&#39;t do these clever type operations, the user can be confident that a sum type with variants <code>A</code>, <code>B</code> and <code>C</code> stays the same type with the same variants.</p>
<p>This enables <em>exhaustive pattern matching</em>: Pattern matching that will detect at compile time if you forget any edge cases. If you&#39;ve used Rust for more than 5 minutes, you already know this is the best thing since sliced bread. If not, I <em>strongly</em> recommend you trying it out just so you know <em>how good</em> this would be to have in Your Favorite Language.</p>
<h2 id=conclusion ><a href="#conclusion" class=header-anchor >Conclusion</a></h2>
<p>There are advantages to both union types and sum types. Quite fittingly, union types play to Julia&#39;s strengths: They enable expressive &#40;low-boilerplate&#41;, generic and fast code. On the other hand, Rust&#39;s sum types enable code with predictable types, and much safer code through forced checking of edge cases.</p>
<p>I&#39;m not convinced this tradeoff between union and sum types is inherent. I think it may be possible to eat your cake and have it, too, but I&#39;m not yet sure how such a system would look like.</p>
<p>Hopefully, that&#39;s a blog post - or a Julia package - for another time&#33;</p>
<div class=page-foot >
  <div class=copyright >
    Jakob Nybo Nissen. Last modified: January 21, 2025. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>