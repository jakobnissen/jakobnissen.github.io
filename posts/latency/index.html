<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/basic.css"> <link rel=icon  href="/assets/v.svg"> <title>Julia&#39;s latency: Past, present and future</title> <header> <div class=blog-name ><a href="/">viralinstruction</a></div> <nav> <ul> <li><a href="/">Home</a> <li><a href="/about/">About</a> <li><a href="/feed.xml">RSS</a> </ul> <img src="/assets/hamburger.svg" id=menu-icon > </nav> </header> <div class=franklin-content ><h1 id=julias_latency_past_present_and_future ><a href="#julias_latency_past_present_and_future" class=header-anchor >Julia&#39;s latency: Past, present and future</a></h1> <p><em>Written 2023-03-31, updated 2023-05-05</em></p> <p>One of the most annoying features of Julia is its <em>latency</em>: The laggy unresponsiveness of Julia after starting up and loading packages.</p> <p>Latency is a major user experience issue that is apparent right away, and shapes the first impressions people have of the language, so naturally, it&#39;s a common complaint when the Internet discusses Julia. In the same threads, you find responses along the lines of:</p> <blockquote> <p>Latency a high priority for the core developers, and being worked on. It has already dropped by an order of magnitude since 1.0, and will continue to drop in the future. If you haven&#39;t given Julia a try for years, it should be much better now</p> </blockquote> <p>But what exactly has happened since Julia v1.0? Has latency really dropped by a factor of 10? And what exactly is planned for the future?</p> <p>In this post, I&#39;ll give a brief history of Julia&#39;s latency, discuss its current status, and speculate on future work to reduce latency further. This post is meant both for potential Julia users curious about the language, but who wants to wait until latency is better before they begin using it, and for current Julia users who are out of the loop about developments in latency and wants to catch up.</p> <p>If you&#39;re impatient, you can skip to <a href="#impact_of_efforts_so_far">a graph summarizing efforts so far</a>.</p> <div class=toc-header >Table of contents</div> <div class=franklin-toc ><ol><li><a href="#the_past_how_we_got_here">The past: How we got here</a><ol><li><a href="#the_pre-15_era_not_much_happens">The pre-1.5 era: Not much happens</a><li><a href="#the_first_obvious_step_cache_more_code">The first obvious step: Cache more code</a><li><a href="#a_brief_primer_of_julia_code_caching">A brief primer of Julia code caching</a><li><a href="#a_brief_primer_on_invalidations">A brief primer on invalidations</a><li><a href="#invalidations_and_uninferability">Invalidations and uninferability</a><li><a href="#reducing_invalidations_v15_-_v17">Reducing invalidations: v1.5 - v1.7</a><li><a href="#precompiletoolsjl_v18">PrecompileTools.jl: v1.8</a><li><a href="#caching_external_codeinstances_v18">Caching external codeinstances: v1.8</a><li><a href="#package_images_v19">Package images: v1.9</a><li><a href="#other_latency_efforts">Other latency efforts</a><li><a href="#impact_of_efforts_so_far">Impact of efforts so far</a><ol><li><a href="#different_packages_are_affected_differently">Different packages are affected differently</a></ol><li><a href="#v19_is_much_faster">v1.9 is much faster</a><li><a href="#not_much_happened_from_v14_to_v17">Not much happened from v1.4 to v1.7</a></ol><li><a href="#the_present_where_are_we_now">The present: Where are we now?</a><ol><li><a href="#1_do_not_commit_type_piracy">1: Do not commit type piracy</a><li><a href="#2_write_inferable_code">2: Write inferable code</a><li><a href="#3_remove_unimportant_dependencies">3: Remove unimportant dependencies</a><li><a href="#4_use_precompiletools">4: Use PrecompileTools</a></ol><li><a href="#the_future_where_is_the_latency_heading">The future: Where is the latency heading?</a><ol><li><a href="#optimise_package_loading">Optimise package loading</a><li><a href="#parallel_compilation">Parallel compilation</a><li><a href="#compile_to_static_libraries_or_binaries">Compile to static libraries or binaries</a><li><a href="#compile-on-demand">Compile-on-demand</a><li><a href="#hybrid_compilerinterpreter">Hybrid compiler/interpreter</a><li><a href="#more_tooling_improvements">More tooling improvements?</a></ol></ol></div> <h2 id=the_past_how_we_got_here ><a href="#the_past_how_we_got_here" class=header-anchor >The past: How we got here</a></h2> <h3 id=the_pre-15_era_not_much_happens ><a href="#the_pre-15_era_not_much_happens" class=header-anchor >The pre-1.5 era: Not much happens</a></h3> <p>Before Julia 1.5, reducing latency was not a top priority for the core developers. Of course, as a major usability problem experienced by daily users, latency <em>did</em> receive some attention, and latency-reducing PRs were made.</p> <p>But back before v1.5, there were other priorities. Pre v1.0, focus was obviously on getting the semantics and API of the language right, since that would be set in stone with the release of 1.0. After 1.0, attention turned towards areas of the language where it was deemed that not fleshing them out quickly could cause long-term problems for the language. For example, the package manager needed to support federated package registries and move away from relying on GitHub, and Julia&#39;s multithreading API had to be established.</p> <p>As a result, nothing much happened regarding latency from around 2017 &#40;where I learned the language&#41; until the spring of 2020. Most of the features that was deemed time critical did land between Julia 1.0-1.4, after which the developers <a href="https://www.youtube.com/watch?v&#61;xKrIp4ZVOrg&amp;t&#61;225s">turned a large part of their attention to reducing latency</a>.</p> <h3 id=the_first_obvious_step_cache_more_code ><a href="#the_first_obvious_step_cache_more_code" class=header-anchor >The first obvious step: Cache more code</a></h3> <p>The first, most promising avenue to dramatically reduce latency caused by compilation was to cache more code. It was believed that in any given session, users would only need to &#40;re&#41;define a tiny fraction of the total amount of compiled code, and therefore only should need to <em>compile</em> a tiny fraction of the code and could theoretically load the rest from a cache serialised to disk.</p> <p>Since Julia v1.0 &#40;and before&#41;, Julia already has two distinct mechanisms for caching code: Code compiled during a session was cached in memory, and code compiled during package installation was cached to disk in a process known as <em>precompilation</em>. However, these two caching mechanisms were severely limited in the pre-1.5 period. To properly explain the issues, it&#39;s worth taking a detour to get an overview of the code caching systems in Julia.</p> <h3 id=a_brief_primer_of_julia_code_caching ><a href="#a_brief_primer_of_julia_code_caching" class=header-anchor >A brief primer of Julia code caching</a></h3> <p>The main purpose of Julia is to be fast, dynamic and interactive at the same time. To achieve this, it&#39;s designed as a thoroughly compiled language that allows dynamic redefinition of methods. Suppose you define the following functions</p> <div class=juliacode ><pre><code class="julia hljs">f(x::<span class=hljs-built_in >Int</span>) = x * <span class=hljs-number >5</span>
g(x) = f(first(x))</code></pre></div> <p>The <em>function</em> <code>f</code> has a single <em>method</em> <code>f&#40;::Int&#41;</code>, whereas the function <code>g</code> has the single method <code>g&#40;::Any&#41;</code>. Julia methods are generic over all their arguments, so the method <code>g&#40;x::Any&#41;</code> is generic over <code>x</code>.</p> <p>When you then call a function, e.g. by calling <code>g&#40;&#91;5&#93;&#41;</code>:</p> <div class=juliacode ><pre><code class="julia hljs">julia&gt; g([<span class=hljs-number >5</span>])
<span class=hljs-number >25</span></code></pre></div> <p>This is what happens:</p> <ul> <li><p>First, the matching method among all the methods of <code>g</code> is found. The details of how this happens is is not relevant here, <a href="https://www.youtube.com/watch?v&#61;gcZJkZqTxso">you can learn about this elsewhere</a>.</p> <li><p>Second, the found method, here, <code>g&#40;::Any&#41;</code> is monomorphized to a <em>methodinstance</em>. That means the compiler creates a non-generic <em>methodinstance</em> <code>g&#40;::Vector&#123;Int&#125;&#41;</code> out of the generic method <code>g&#40;x::Any&#41;</code> by looking at the actual, concrete types of the arguments at runtime &#40;namely <code>Vector&#123;Int&#125;</code>&#41;.</p> <li><p>Then, <em>after</em> the code has been monomorphized, and the methodinstance compiled, the methodinstance is called and its value returned. Since the methodinstance is not generic but only contains concrete types, the compiler is able to generate efficient code despite Julia being dynamic. In this case, it just returns a literal <code>25</code>.</p> </ul> <p>Invoking the compiler at <em>every</em> function call would be totally unworkable, so this scheme only works due to two important optimisations: First, every methodinstance is cached in memory. When the method <code>g&#40;::Any&#41;</code> is called, e.g. as <code>g&#40;&#91;5&#93;&#41;</code>, Julia looks up in the cache whether a methodinstance with the signature <code>g&#40;::Vector&#123;Int&#125;&#41;</code> exists. If not, it compiles the methodinstance and saves it to cache. If it does, it simply fetches the compiled code and executes it.</p> <p>Second, since the compiler statically knows that <code>g&#40;::Vector&#123;Int&#125;&#41;</code> will call <code>f&#40;::Int&#41;</code>, Julia first compiles <code>f&#40;::Int&#41;</code> before <code>g&#40;::Vector&#123;Int&#125;&#41;</code>, then statically inserts the function call to <code>f</code> into <code>g</code>. So, when <code>f</code> is called from <code>g</code>, there is no need to look <code>f</code> up in the cache. Essentially, when the compiler knows at compile time what methods it needs to call, it behaves like a normal static language, with all the performance gains that come from that.</p> <p>Besides caching already-compiled methodinstances in memory, packages may also <em>precompile</em> some of their methods. The idea here is that if a package defines some method <code>foo</code>, the method might as well be compiled when the package in installed. The compiled code can be serialised to disk, then loaded when the user loads the package, similar to a normal static language.</p> <p>In the pre-1.5 era, both types of caching had significant limitations that needed to be lifted to improve caching, and hence latency. The main problem was that there was widespread <em>cache invalidation</em>: A large fraction of methods were being compiled and stored in the cache, only to then be cleared from the cache and re-compiled. It was believed that addressing invalidations was the most important first step: By reducing invalidations, less code had to be recompiled, leading to easy latency wins. Furthermore, any other optimisations to the cache would be defeated if most of the cached code had to be invalidated anyway.</p> <p>Thus, after the release of Julia 1.4, the developers and especially Timothy Holy, started hunting down invalidations.</p> <h3 id=a_brief_primer_on_invalidations ><a href="#a_brief_primer_on_invalidations" class=header-anchor >A brief primer on invalidations</a></h3> <p>As shown above, Julia 1&#41; caches compiled methodinstances in memory, and 2&#41; is, like other compiled languages, able to insert static callsites and inline functions.</p> <p>Unfortunately, these two optimisations conflict somewhat with having a dynamic, interactive language. For example, if I define the functions <code>f</code> and <code>g</code> as above, I can then redefine <code>f</code> - and <code>g</code> must still work<sup id="fnref:1"><a href="#fndef:1" class=fnref >[1]</a></sup> :</p> <div class=juliacode ><pre><code class="julia hljs">julia&gt; f(x::<span class=hljs-built_in >Int</span>) = x + <span class=hljs-number >1</span>;

julia&gt; g([<span class=hljs-number >5</span>])
<span class=hljs-number >6</span></code></pre></div> <p>However, since the call to <code>f</code> was inlined into <code>g</code>, this means redefining <code>f</code> must also cause <code>g</code> to be recompiled. This works by having a <em>backedge</em> from all methodinstances to all of its callers - in this case, from <code>f&#40;::Int&#41;</code> to <code>g&#40;::Vector&#123;Int&#125;&#41;</code>. Redefining a method will <em>invalidate</em> the cache entry for all of that method&#39;s methodinstances, which then invalidates all the methodinstances pointed to by their backedges, which in turn invalidates all the methodsinstances pointed to by <em>those methodinstances&#39;</em> backedges, and so on.</p> <p>Thus, when a method is redefined, a large number of methodinstances may need to be re-compiled, including sometimes methodinstances in the Julia language, package manager, or compiler itself, leading to latency.</p> <p>Luckily, people actually rarely redefine existing methods. Doing so essentially redefines existing behaviour, which other code may rely on, potentially causing correctness problems. Julians have coined the term <em>type piracy</em> for this nasty behaviour, and it is considered faux pas: An author may extend functions they defined themselves with new methods, or they may extend other people&#39;s functions with methods whose signature contain types they defined themselves. But defining a method for a function in someone else&#39;s code, using only someone else&#39;s types is frowned upon as &quot;type piracy&quot;.</p> <p>Incidentally, this is analogous to Rust&#39;s &quot;orphan rule&quot; - except that Rust&#39;s compiler makes it <em>impossible</em> to break the orphan rule, whereas in Julia, we acknowledge that it may occasionally be convenient to commit type piracy &#40;say, between two packages under the same project&#41;, and so we merely advise you against doing it.</p> <p>Type piracy can lead to massive cache invalidations, but it&#39;s fortunately rare, so it does not account for the large-scale invalidations prior to Julia 1.5. To understand <em>those</em>, we have to look at how Julia deals with <em>uninferable code</em>, that is, code where the compiler doesn&#39;t know the types of all variables.</p> <h3 id=invalidations_and_uninferability ><a href="#invalidations_and_uninferability" class=header-anchor >Invalidations and uninferability</a></h3> <p>Because Julia is supposed to be expressive, high-level, dynamic and interactive, it&#39;s an absolute non-starter to require Julia code to be completely inferable, as static languages require. It <em>must</em> be possible to run, and therefore compile, code where the compiler does not know all types, and so the Julia compiler is designed to handle a kind of &quot;gradual typing&quot;, where only partial type information is known.</p> <p>Of course, with only partial type information, the compiler is limited in its optimisations, and must produce code that is slower and which checks all unknown types at runtime. Nonetheless, it has been a focus for the Julia developers to create a compiler that can produce reasonably fast code even with limited type information.</p> <p>Let&#39;s look at an example. Suppose I have the same definitions as above:</p> <div class=juliacode ><pre><code class="julia hljs">f(x::<span class=hljs-built_in >Int</span>) = x * <span class=hljs-number >5</span>
g(x) = f(first(x))</code></pre></div> <p>But now, this time, I call the method <code>g&#40;::Any&#41;</code> with an un-typed container: <code>g&#40;Any&#91;5&#93;&#41;</code>. Now, the compiler has no information about the type of <code>first&#40;x&#41;</code>. The Julia IR created by the compiler for the methodinstance <code>g&#40;::Vector&#123;Any&#125;&#41;</code> is:</p> <pre><code class="julia hljs">julia&gt; <span class=hljs-meta >@code_typed</span> g(<span class=hljs-built_in >Any</span>[<span class=hljs-number >5</span>])
CodeInfo(
<span class=hljs-number >1</span> ─ %<span class=hljs-number >1</span> = Base.arrayref(<span class=hljs-literal >true</span>, x, <span class=hljs-number >1</span>)::<span class=hljs-built_in >Any</span>
│   %<span class=hljs-number >2</span> = (<span class=hljs-keyword >isa</span>)(%<span class=hljs-number >1</span>, <span class=hljs-built_in >Int64</span>)::<span class=hljs-built_in >Bool</span>
└──      goto <span class=hljs-comment >#3 if not %2</span>
<span class=hljs-number >2</span> ─ %<span class=hljs-number >4</span> = <span class=hljs-literal >π</span> (%<span class=hljs-number >1</span>, <span class=hljs-built_in >Int64</span>)
│   %<span class=hljs-number >5</span> = Base.mul_int(%<span class=hljs-number >4</span>, <span class=hljs-number >5</span>)::<span class=hljs-built_in >Int64</span>
└──      goto <span class=hljs-comment >#4</span>
<span class=hljs-number >3</span> ─ %<span class=hljs-number >7</span> = Main.f(%<span class=hljs-number >1</span>)::<span class=hljs-built_in >Int64</span>
└──      goto <span class=hljs-comment >#4</span>
<span class=hljs-number >4</span> ┄ %<span class=hljs-number >9</span> = φ (<span class=hljs-comment >#2 =&gt; %5, #3 =&gt; %7)::Int64</span>
└──      <span class=hljs-keyword >return</span> %<span class=hljs-number >9</span>
) =&gt; <span class=hljs-built_in >Int64</span></code></pre> <p>This is <a href="https://docs.julialang.org/en/v1/devdocs/ssair/">Julia IR</a>, which might be a little hard to read, but the code is equivalent to:</p> <div class=juliacode ><pre><code class="julia hljs">y = x[<span class=hljs-number >1</span>]
<span class=hljs-keyword >if</span> y <span class=hljs-keyword >isa</span> <span class=hljs-built_in >Int</span>
    y*<span class=hljs-number >5</span>
<span class=hljs-keyword >else</span>
    typeassert(<span class=hljs-built_in >Int</span>, f(y))
<span class=hljs-keyword >end</span></code></pre></div> <p>I.e. Julia can&#39;t predict the type of <code>y &#61; x&#91;1&#93;</code> - it infers it to be of type <code>Any</code>. However, it knows <code>f&#40;y&#41;</code> is the next step, and <code>f</code> is only &#40;so far&#41; defined as <code>f&#40;::Int&#41;</code>, therefore it checks if <code>y</code> is an <code>Int</code> and if so, returns <code>y*5</code> &#40;having inlined <code>f&#40;::Int&#41;</code>&#41;. If not, it calls <code>f&#40;y&#41;</code> in order to throw a <code>MethodError</code>.</p> <p>So: The compiler managed to emit efficient code even with <em>no</em> type information about the argument to <code>f</code> - good job&#33; Unfortunately, it means that now, the code of <code>g</code> is only correct if there is only that one method of <code>f</code> - defining a new method of <code>f</code>, <em>without committing type piracy</em>, will invalidate <code>g</code>. For example, if I define:</p> <div class=juliacode ><pre><code class="julia hljs">f(::<span class=hljs-built_in >Float64</span>) = <span class=hljs-number >1.0</span></code></pre></div>
<p>Then <code>g</code> will be invalidated, because it needs to be re-compiled to:</p>
<div class=juliacode ><pre><code class="julia hljs">y = x[<span class=hljs-number >1</span>]::<span class=hljs-built_in >Any</span>
<span class=hljs-keyword >if</span> y <span class=hljs-keyword >isa</span> <span class=hljs-built_in >Int</span>
    y*<span class=hljs-number >5</span>
<span class=hljs-keyword >elseif</span> y <span class=hljs-keyword >isa</span> <span class=hljs-built_in >Float64</span>
    <span class=hljs-number >1.0</span>
<span class=hljs-keyword >else</span>
    f(y)::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Float64</span>, <span class=hljs-built_in >Int</span>}
<span class=hljs-keyword >end</span></code></pre></div>
<p>And here we come to the crux of the matter: Uninferable code is vulnerable to being invalidated <em>simply by defining new methods</em>. When loading packages, with hundreds of new method definitions, <a href="https://julialang.org/blog/2020/08/invalidations/#how_common_is_method_invalidation">thousands of methodinstances may be invalidated</a>, each of which must be re-compiled. The very optimisations that the compiler uses to regain performance when running poorly inferred code are the same causing large scale cache invalidations and blocking any improvements to Julia&#39;s code caching.</p>
<h3 id=reducing_invalidations_v15_-_v17 ><a href="#reducing_invalidations_v15_-_v17" class=header-anchor >Reducing invalidations: v1.5 - v1.7</a></h3>
<p>A major goal, therefore of Julia 1.5 and 1.6, was to reduce the amount of code cache invalidations.</p>
<p>A big part of the effort went into developing tooling to measure Julia&#39;s compiler in order to gain a better understanding of the details of the problem: The packages <a href="https://github.com/timholy/SnoopCompile.jl">SnoopCompile.jl</a>, <a href="https://github.com/timholy/MethodAnalysis.jl">MethodAnalysis.jl</a>, <a href="https://github.com/JuliaDebug/Cthulhu.jl">Cthulhu.jl</a> and <a href="https://github.com/aviatesk/JET.jl">JET.jl</a> were all created, or received much attention, during this period.</p>
<p>The compiler itself was also improved to reduce invalidations: <a href="https://github.com/JuliaLang/julia/pull/36733">PR 36733</a> refined the invalidation algorithm, thereby exempting some methods that didn&#39;t need invalidation from being so. PRs <a href="https://github.com/JuliaLang/julia/pull/36208">36208</a> and <a href="https://github.com/JuliaLang/julia/pull/35904">35904</a> limited the aggressiveness of the optimisations that tries to regain performance from poorly-inferred code, which, as we saw above, could lead to invalidations.</p>
<p>However, most of the improvements between Julia 1.5-1.7, came from simply fixing uninferable code in Base Julia - all packages rely on Base, so invalidations of Base code had by far the worst impact on latency. Among other people, Tim Holy made a flurry of PRs between Julia 1.5 and 1.7 to improve inference of Base.</p>
<p>The job of reducing invalidations by improving inference continues to this day, although all the truly awful cases have been fixed by now. In the words of Tim Holy, the invalidations we hunt now are like geckos, compared to the dinosaurs that used to stomp around before Julia 1.6.</p>
<p>The reduction of invalidations between v1.5 and 1.7 directly improved latency, but perhaps more importantly paved the way for improving precompilation. </p>
<h3 id=precompiletoolsjl_v18 ><a href="#precompiletoolsjl_v18" class=header-anchor >PrecompileTools.jl: v1.8</a></h3>
<p>One major problem with precompiling code during package installation time is that all Julia methods are generic over all their arguments. Hence, if I create a package where I define a method <code>foo&#40;a, b, c&#41;</code>, there is no way for the compiler, only based on the method definition, to know which methodinstance&#40;s&#41; I would want to compile from the method.</p>
<p>Before v1.8, package authors could add precompilation statements of the form:</p>
<pre><code class="julia hljs">precompile(foo, (MyType, <span class=hljs-built_in >Int</span>, <span class=hljs-built_in >String</span>))</code></pre>
<p>to cache the methodinstance <code>foo&#40;::MyType, ::Int, ::String&#41;</code>. Unfortunately, creating these statements and copy-pasting them into your code were a pain in the butt, and so very few package authors bothered to do so. This changed with Julia 1.8, when the package <a href="https://github.com/JuliaLang/PrecompileTools.jl">PrecompileTools.jl</a> &#40;originally called <a href="https://github.com/timholy/SnoopCompile.jl">SnoopPrecompile.jl</a>&#41; was released. With it, authors simply need to create a block of code, that uses functionality from the package, and wrap it in a <code>@compile_workload</code> macro. When running the macro, PrecompileTools will record all methods being compiled during execution of the code, and automatically emit precompilation statements for these during package installation time. Even cooler, this <em>only</em> happens during package installation: During normal package loading, the entire PrecompileTools codeblock will be compiled to a no-op, thus contributing minimally to latency itself.</p>
<p>For example, a user could add this to their package:</p>
<div class=juliacode ><pre><code class="julia hljs"><span class=hljs-meta >@compile_workload</span> <span class=hljs-keyword >begin</span>
    subjects = load_data(<span class=hljs-string >&quot;test/file.csv&quot;</span>)
    results = full_analysis(subjects)
    [ more statement ]
<span class=hljs-keyword >end</span></code></pre></div>
<p>and all functions called by any function inside the block would be precompiled. This way, PrecompileTools made precompilation so easy that any package author who cares about latency can precompile much of their code. As of April 2023, PrecompileTools has 148 direct dependents, a number that I very much hope will continue to grow in the future.</p>
<h3 id=caching_external_codeinstances_v18 ><a href="#caching_external_codeinstances_v18" class=header-anchor >Caching external codeinstances: v1.8</a></h3>
<p>Before Julia 1.8, a large fraction of methodinstances could not be compiled, even if precompile statements were generated for them. The reason was that packages could only save code that &quot;belonged&quot; to the package itself, i.e. methodinstances for which either the function, or one of the arguments were defined in the package. If package A imported function <code>f</code> from package X and type <code>T</code> from package Y, then called <code>f&#40;::T&#41;</code>, that methodinstance did not belong to package A, and was therefore not eligible for precompilation<sup id="fnref:2"><a href="#fndef:2" class=fnref >[2]</a></sup>.</p>
<p><a href="https://github.com/JuliaLang/julia/pull/43990">PR 43990</a> enabled packages to also cache &quot;external codeinstances&quot;, namely code defined in other packages. This, in theory, enabled caching of essentially all function calls. The combination of this PR with PrecompileTools made precompilation far more widespread and was the reason for the observed drop in latency many packages experienced from Julia 1.7 to Julia 1.8.</p>
<h3 id=package_images_v19 ><a href="#package_images_v19" class=header-anchor >Package images: v1.9</a></h3>
<p>Another major issue with precompilation was that only a small part of the whole compilation pipeline could be precompiled. Briefly, Julia&#39;s compiler process code in several steps:</p>
<ul>
<li><p>First, Julia source code is lowered to... well, lowered code, the highest level of Julia IR, with a fairly straightforward correspondence to source code. This always happens at precompile time to all source code, such that raw source code is never loaded from disk.</p>

<li><p>Then, type inference is run on the lowered code. This is the step that requires monomorphization, and therefore a precompile statement &#40;or a PrecompileTools block&#41; in order to determine the concrete methodinstances to compile.</p>

<li><p>Third, Julia&#39;s front-end compiler will optimise the lowered code using the usual compiler tricks such as inlining, loop hoisting etc into fairly low-level Julia-like code. With the changes in v1.8, practically all code up to and including this level could be cached.</p>

<li><p>Finally, Julia emits LLVM code from its IR, and calls into LLVM to produce machine code from that.</p>

</ul>
<p>Prior to Julia 1.9, the native code from this last step could not be cached to disk during precompilation. LLVM is famously slow, so not the uncacheability of this bottleneck was a major restriction of precompilation. This changed with <a href="https://github.com/JuliaLang/julia/pull/44527">PR 44527</a> and <a href="https://github.com/JuliaLang/julia/pull/47184">PR 47184</a>, such that in v1.9, the result of all steps of the compiler can be cached during precompilation.</p>
<p>Hence, from version 1.9, all code can be cached, and theoretically, no code actually needs to be compiled by the user &#40;though in practice, users probably wants to define and compile some new methods themselves&#41;. The last major step in the long process of improving code caching was complete.</p>
<h3 id=other_latency_efforts ><a href="#other_latency_efforts" class=header-anchor >Other latency efforts</a></h3>
<p>In 1.6, precompilation was parallelised. This only sped up package installation time &#40;which I do not consider &quot;latency&quot; in this article&#41;, but in doing so incentivized developers to move more work to precompile time, so is worth mentioning.</p>
<p><a href="https://github.com/JuliaLang/julia/pull/43852">PR 43852</a> and many follow-up PRs upgraded the compiler&#39;s reasoning about side effects from Julia 1.8 onwards, allowing the compiler to use the faster constant evaluation instead of constant folding/propagation.</p>
<p><a href="https://github.com/JuliaLang/julia/pull/45276">PR 45276</a> in Julia 1.9 makes the compiler scale better with the length of functions. This only really matters for packages that uses huge functions, typically programmatically generated functions.</p>
<p><a href="https://github.com/JuliaLang/julia/pull/47695">PR 47695</a> in Julia 1.9 added <em>package extensions</em>, which allow users to extend code from other packages without having them as dependencies. It is still to early to tell the impact of this PR, but it could potentially significantly lower the number of dependencies of packages throughout the ecosystem, thereby indirectly lower latency.</p>
<h3 id=impact_of_efforts_so_far ><a href="#impact_of_efforts_so_far" class=header-anchor >Impact of efforts so far</a></h3>
<p>So: How much have all these initiatives mattered? To check it, I made five different latency-heavy workloads, and tested them on 6 different versions of Julia. Since the packages themselves develop over time, often in response to the evolution of Julia, I created virtual environments for each package/version pair, such that e.g. when timing Plots on Julia 1.4, the entire environment only uses Julia packages with the versions available at the time of Julia 1.4.</p>
<p><img src="/assets/latency_lineplot.png" alt="" /></p>
<h4 id=different_packages_are_affected_differently ><a href="#different_packages_are_affected_differently" class=header-anchor >Different packages are affected differently</a></h4>
<p>The first thing to notice is that the development of latency across time differs <em>massively</em> by workload. Plots.jl is doing well and getting faster most releases - but this is not surprising. Plots.jl has become the posterboy for latency, and has become the unofficial latency benchmark for the Julia developers. Indeed, latency is often referred to as &quot;time to first plot&quot;. New latency-related PRs are usually gauged by measuring their impact on Plots.jl, so regressions in Plots.jl would be quickly discovered. So, Plots.jl does better most Julia releases because <em>Julia has become optimised for running Plots.jl</em>. We also see FASTX.jl mostly improving. This package is particularly &quot;well behaved&quot;: It&#39;s thoroughly inferable, does not commit type piracy, and much of its heavy lifting happens during precompilation. In contrast, DataFrames&#39; latency bizarrely more-than-doubled from v1.4 to v1.7, and was still ~40&#37; slower in v1.8 than in v1.4. JSON3 and JuliaFormatter are more typical - they largely get slower from v1.4 to v1.7, but then get faster again in v1.8 and 1.9.</p>
<h4 id=v19_is_much_faster ><a href="#v19_is_much_faster" class=header-anchor >v1.9 is much faster</a></h4>
<p>The next to notice is that huge strides has been made in Julia 1.9. All workloads are by far fastest in this latest release. Compared to v1.4, the latency is between 3 and 13 times lower - in absolute terms, it dropped from 11 seconds to 0.9 seconds for JuliaFormatter and from 19 to 3 seconds for Plots, whereas DataFrames &quot;only&quot; dropped from 9 to 3 seconds, and FASTX from 2.6 to 0.7 seconds.</p>
<h4 id=not_much_happened_from_v14_to_v17 ><a href="#not_much_happened_from_v14_to_v17" class=header-anchor >Not much happened from v1.4 to v1.7</a></h4>
<p>This was the most surprising finding to me - Julia v1.6 was widely considered a quantum leap in terms of latency, and there has been a continuous stream of smaller latency-focused PRs since v1.6 not mentioned in this blog post. Yet in the plot, for three of the five workloads, Julia v1.7 is worse than Julia v1.4. Why are the fruits of these efforts not visible in the plot - indeed, why does it get <em>worse</em>?</p>
<p>One explanation could be that I just picked particularly unlucky packages. Anecdotally, some packages like SIMD.jl and LoopVectorization.jl experienced massive improvements when invalidations were reduced in Julia 1.6, but I happened to not pick any using these packages for my test. However, I don&#39;t think the packages I chose are particularly unlucky - certainly not Plots.jl or FASTX.jl - and besides, the improvements to latency are widely assumed to apply to packages generally, not just select packages.</p>
<p>Another factor could be that latency improvements are matched one-for-one with regressions introduced by new compiler capabilities. Since Julia v1.4, the compiler has gotten significantly smarter and will, among other things, constant-fold/evaluate much more aggressively, elide boundschecks automatically if safe, and generally infer better. It is well known that, without a concerted effort to retain compiler speed, it tends to regress over time as they accumulate more features. <a href="https://www.npopov.com/2020/05/10/Make-LLVM-fast-again.html">This has famously happened to LLVM</a>, the compiler backend used by Julia. I personally think the new compiler improvements are awesome and worth the latency, but it&#39;s worth thinking about the cost.</p>
<p>Perhaps more importantly, packages tend to get larger over time. From 1.4 to 1.9, DataFrames.jl doubled from 11k to 22k lines of code, exclusive dependencies which increased from 17 to 23. In the same span, Plots.jl went from 26 to 36 dependencies &#40;although cutting about 15&#37; of its lines of code&#41;. There is something almost profound about how, due to Julia&#39;s package manager being so great, it is almost <em>too easy</em> to add new dependencies, a situation <a href="https://blog.kodewerx.org/2020/06/the-rust-compiler-isnt-slow-we-are.html">which has been remarked on with Rust&#39;s Cargo</a>.</p>
<p>It&#39;s worth noting that these dynamics may warp the language developers&#39; understanding of how much progress they are making. From their point of view, they are merging PR after PR showing significant latency improvements &#40;for Plots.jl&#41;, for years on end. Surely, they might think, latency must have dropped significantly after all those PRs? Yet, my data shows differently. This is probably why some Julia developers in various ways on various forums have been saying that latency has been reduced &quot;by an order of magnitude&quot;, even before 1.8 - when in fact, many, perhaps <em>most</em>, packages saw latency getting worse and worse.</p>
<h2 id=the_present_where_are_we_now ><a href="#the_present_where_are_we_now" class=header-anchor >The present: Where are we now?</a></h2>
<p>The most impactful changes so far has been about allowing package authors to precompile more of their their packages. With package images in v1.9, precompilation has been massively improved and is in the grand scheme of things <em>done</em>, enabling speedups that are <em>actually</em> an order of magnitude.</p>
<p>But the keyword here is <em>enabling</em> - the efforts only bear fruit if package authors exploit them. We&#39;ve already seen many packages get serious about precompilation but I believe latency in the package ecosystem is currently far worse than <a href="https://sciml.ai/news/2022/09/21/compile_time/">what Julia makes possible</a>, and we could all have significantly lower latency if we only made use of the advances that has been made. </p>
<p>So - how do you do make your package precompilable as an author? The good news is that the same steps that reduce latency and enable precompilation are also things that improve the general code quality of your package. Hence, as a package author, you should see it less as &quot;fiddling with your code to make the compiler happy&quot; and more as &quot;cleaning up the package before release&quot;. In fact, I&#39;ve come to believe that <em>most packages should not optimise latency directly</em>, and huge strides can be made if package authors simply follow a few guidelines about general code quality:</p>
<h3 id=1_do_not_commit_type_piracy ><a href="#1_do_not_commit_type_piracy" class=header-anchor >1: Do not commit type piracy</a></h3>
<p>Don&#39;t get in the habit of committing type piracy. Not only for latency reasons, mainly because redefining other people&#39;s code is terrible practice and leads to correctness issues. If you feel type piracy is necessary, it typically means you need to refactor your packages, or need to make a PR upstream to one of your dependencies.</p>
<p>The package Aqua.jl &#40;Automatic QUality Assurance of packages&#41; can statically find piracy and can be integrated in your test suite and CI. In general, Aqua.jl includes a lot of nice functionality to make your package better.</p>
<h3 id=2_write_inferable_code ><a href="#2_write_inferable_code" class=header-anchor >2: Write inferable code</a></h3>
<p>Get in the habit of writing inferable code. If you&#39;re uncertain if, or why, a function is uninferable, use <code>@code_warntype</code>, or, preferably, the more featureful <code>@descend</code> from Cthulhu.jl&#39;s to investigate. Inferable code is faster at runtime - also after compilation - it is more debuggable, behaves more predictable and can be analysed statically. Don&#39;t worry - writing inferable code by default quickly becomes a habit. In fact, I would argue that building the habit of writing inferable code makes you a better programmer.</p>
<p>If you have a larger codebase which is uninferable, you can use VSCode&#39;s profiler to profile a workload and detect all calls where dynamic dispatch happens. Alternatively, you can use JET.jl on your PrecompileTools workload to detect dynamic dispatch in your code and fix it.</p>
<p>Strive to have near zero dynamic dispatch for your workload - usually, writing idiomatic Julia code will be enough to do that. For tasks that are inherently type unstable, like parsing JSON, you can add typeasserts to limit the scope of type instability.</p>
<h3 id=3_remove_unimportant_dependencies ><a href="#3_remove_unimportant_dependencies" class=header-anchor >3: Remove unimportant dependencies</a></h3>
<p>It&#39;s common to see packages take on dependencies for trivial tasks. Ask yourself if you really need them - remember that dependencies not only add latency, they are also a source of potential bugs, installation issues and upgrade deadlock.</p>
<p>You also see packages add dependencies, not because they need them, but simply to allow interoperability with them. For example, suppose I write a package that defines <code>my_function</code>. The package does not depend on the popular <code>OtherType</code> type from OtherPackage.jl, but for users who <em>do</em> use OtherPackage.jl, it&#39;s convenient to have defined <code>my_function&#40;::OtherType&#41;</code>, so therefore I add OtherPackage.jl to my dependencies. This allows me to have this great new feature, but <em>all</em> users, even those who do not care about interoperability with OtherPackage.jl now bears its latency.</p>
<p>With Julia 1.9, it&#39;s possible to have modules that are conditionally loaded when specific packages are in your environment - so called &quot;package extensions&quot;. Hence, you could define a package extension that defines <code>my_function&#40;::OtherType&#41;</code> ONLY when OtherPackage is loaded, but where OtherPackage is not a dependency of your package.</p>
<p>Finally, many packages include dependencies that are only used when developing or testing the package, such as <code>Test</code>, <code>BenchmarkTools</code> or <code>JuliaFormatter</code>. Don&#39;t make your users pay for the latency of loading these packages at runtime - add them in dedicated testing and development environments.</p>
<h3 id=4_use_precompiletools ><a href="#4_use_precompiletools" class=header-anchor >4: Use PrecompileTools</a></h3>
<p>Add PrecompileTools as a dependency and execute a representative workload which exercises the main functionality of your package in top-level scope of your package:</p>
<div class=juliacode ><pre><code class="julia hljs"><span class=hljs-meta >@compile_workload</span> <span class=hljs-keyword >begin</span>
    x = MyHugeType(<span class=hljs-string >&quot;abc&quot;</span>)
    modify!(x)
    [ ... ]
<span class=hljs-keyword >end</span></code></pre></div>
<p>In general, you want your workload to eventually end up calling all the functions you want to precompile. For advanced users, you can use SnoopCompile.jl to determine which methods are compiled at runtime and therefore perhaps should be part of the workload - but as a package author, you probably have a pretty good idea about the main functionality of your own package.</p>
<p>Adding a PrecompileTools workload is the only latency-reducing measure you need to take which is specifically latency-reducing, and does not improve the overall code quality. Luckily, it&#39;s quick and easy to do.</p>
<h2 id=the_future_where_is_the_latency_heading ><a href="#the_future_where_is_the_latency_heading" class=header-anchor >The future: Where is the latency heading?</a></h2>
<p>The immediate future is easy to predict, because the same things that has been happening for years will continue to happen: Some of the exciting recent advances will be cancelled out by new compiler regressions due to fancy new compiler features. We users will create still deeper code stacks that racks up latency, even more so with Julia 1.9 now that latency has improved and we can &quot;afford&quot; to do so.</p>
<p>On the other hand, I&#39;m also optimistic that Julia 1.9 may change some user behaviour for the better. In the old days, optimising your package for latency sometimes meant jumping through hoops to optimise for obscure compiler internals, all for limited gain. Now, latency can be reduced manyfold by simply implementing bog-standard code quality improvements and a PrecompileTools workload. Today, you also have tooling like JET.jl, Aqua.jl and the VSCode profiler to make it easier. This both lowers the barrier to, and increases the incentive to write inferable, precompilable packages, compared to just a few years ago. I&#39;m hopeful that more package authors will adopt these practises, and the resulting improvements to latency will propagate through the ecosystem.</p>
<p>However, there are also more work to do on the Julia development side, which will presumably happen slowly over the next several years:</p>
<h4 id=optimise_package_loading ><a href="#optimise_package_loading" class=header-anchor >Optimise package loading</a></h4>
<p>Loading packages have traditionally been slow for two reasons: First, the package loading itself &#40;i.e, loading all the defined methods and types&#41;, and second, the compilation of new methods, or old methods invalidated by the newly loaded code.</p>
<p>The recent changes to invalidations and code caching has massively improved the latter, but code loading itself is only moderately faster today than 2 years ago. Hence, while the total DataFrames workload latency decreased from 9 to 3 seconds, loading only decreased from 2.0 to 1.6 seconds, and thus went from ~20&#37; to ~50&#37; of total time. For the JuliaFormatter workload, loading time actually increased by 50&#37; from 0.4 to 0.6 seconds, even as total latency dropped from 11 to 0.9 seconds, such that loading went from 1/25th of the latency to 2/3rds&#33;</p>
<p>With most attention so far having been put on compilation, not loading, there are presumably some low-hanging fruits in code loading, and it&#39;s an obvious next target for latency improvements. The Julia devs are pretty confident that code loading itself can be made faster than it already is in v1.9, and I&#39;m guessing it will be improved significantly &quot;soon&quot; - so, probably, over the next releases, 1.10 or 1.11.</p>
<h4 id=parallel_compilation ><a href="#parallel_compilation" class=header-anchor >Parallel compilation</a></h4>
<p>Julia&#39;s compiler is mostly single-threaded, although select parts of it, such as precompilation, happen in parallel. Adding more parallelism is an obvious area of improvement, indeed, it&#39;s slightly ironic that a language with such easy multithreading as Julia doesn&#39;t itself have a multithreaded compiler. The last year or so, the developer Prem Chintalapudi has been <a href="https://github.com/JuliaLang/julia/pulls?q&#61;is&#37;3Apr&#43;author&#37;3Apchintalapudi">laying groundwork to introduce more parallelism</a>. Most recently, <a href="https://github.com/JuliaLang/julia/pull/47797">PR 47797</a> parallelised system image building, adding more parallelism to precompilation. There is still some way to go until Julia&#39;s compiler can use multiple threads for compilation during a session or script, but <a href="https://www.youtube.com/watch?v&#61;A0VwcXcAz4o">it is on the horizon</a>, meaning it will hopefully land over the next few years.</p>
<h4 id=compile_to_static_libraries_or_binaries ><a href="#compile_to_static_libraries_or_binaries" class=header-anchor >Compile to static libraries or binaries</a></h4>
<p>Julia already compile to machine code - it just compiled directly in the memory of your computer. Then why can&#39;t it compile the same code to binaries or libraries? Indeed, there is nothing <em>fundamental</em> in Julia preventing this - it simply hasn&#39;t been implemented yet.</p>
<p>There has already been some foundational work to enable this. <a href="https://github.com/JuliaLang/julia/pull/41936">PR 41936</a> allowed separating the codegen part from the Julia runtime, allowing you to start run Julia without the compiler. The Julia devs have also hinted that more foundational work is happening. The package <a href="https://github.com/tshort/StaticCompiler.jl">StaticCompiler.jl</a> already now is able to produce small executables from Julia code - but it is experimental and brittle at this stage.</p>
<p>I&#39;m not aware of any concrete plans to implement this, so I think it&#39;s safe to assume this is still very hypothetical, and probably won&#39;t happen for the next several years. I certainly wouldn&#39;t hold my breath waiting for it.</p>
<h4 id=compile-on-demand ><a href="#compile-on-demand" class=header-anchor >Compile-on-demand</a></h4>
<p>In general, Julia will compile functions when they are called - <em>except</em> in the case where it statically knows function <code>g</code> calls function <code>f</code>. Then, it will compile <code>f</code> when also compiling <code>g</code>.</p>
<p>Usually, this is what you want - if <code>f</code> will be called anyway during the execution of <code>g</code>, you might as well compile it when you compile <code>g</code>. However, some code paths may not be taken in any particular session, meaning some functions that are statically identified may never need to be compiled.</p>
<p>LLVM has functionality for this &quot;compile on demand&quot;, and Prem Chintalapudi is working on it currently.</p>
<h4 id=hybrid_compilerinterpreter ><a href="#hybrid_compilerinterpreter" class=header-anchor >Hybrid compiler/interpreter</a></h4>
<p>More speculatively, the developers have talked about executing Julia using an interpreter, then compiling the same code in a background thread, and switching execution from the interpreted version to the compiled version when the compiled version is done.</p>
<p>This is pretty tricky for Julia in particular: The language has come to <em>depend</em> on an efficient compiler to produce code with any reasonable runtime performance. Primarily because Julia is mostly implemented in Julia, all the way down to low-level integer operations, running Julia through an interpreter adds way more overhead than for e.g. Python, whose interpreter can simply offload all the low-level stuff to Python&#39;s internals written in C. Also, idiomatic Julia tends to be written in a way that makes use of copious zero-cost abstractions, expecting their cost to be compiled away before runtime. Hence, a Julia interpreter is <em>massively</em> slower than even Python, and would need serious performance overhauls and some clever design before it would be suitable as the go-to code executor. So, a hybrid compiler/interpreter is at the moment highly speculative optimisation, and as far as I know, no actual work has been done in this area so far, so if this optimisation ever lands, it will take many years.</p>
<h4 id=more_tooling_improvements ><a href="#more_tooling_improvements" class=header-anchor >More tooling improvements?</a></h4>
<p>This is sort of a joker, because tooling to allow developers to reduce latency has already improved quite a lot, and it&#39;s difficult as a user to put my finger on <em>exactly what</em> kind of tooling I&#39;d like to see getting build. Nonetheless, I feel strongly that there could exist better tooling which would guide developers more easily towards writing low-latency code. This is a common user experience for all software: Users can easily tell that something isn&#39;t quite as nice as it could be, but can&#39;t articulate what it should be instead. Nonetheless, let me try:</p>
<ol>
<li><p>It is currently still too difficult to automatically diagnose type piracy. Ideally, a package like Aqua should detect all instances of type piracy, and for each instance, explicitly tell you in which package the function and each argument is defined. Even more ideally, a piracy check should be an automatic part of the language server, such that your IDE will put a fat, red line under a method definition if it&#39;s a pirate.</p>

<li><p>While JET.jl makes it easy to detect inference problems, the output is not provided in a way that is particularly actionable: It does not display the call chain that leads to uninferability with all types, such that you can easily identify the function call where type information is lost, it does not flag abstractly typed containers, and there are still too many &quot;false positives&quot; from places like Base where users can&#39;t do anything about them. This is particularly true when you run <code>@report_opt</code> on a large, type unstable code base.</p>

</ol>
<p><table class=fndef  id="fndef:1">
    <tr>
        <td class=fndef-backref ><a href="#fnref:1">[1]</a>
        <td class=fndef-content >Famously, this used to <em>not</em> work in Julia back before I learned the language: If a method was redefined &#40;or even if a new, more applicable method was defined&#41;, any callers would not get updated, and would simply return the wrong answer. This was tracked in <a href="https://github.com/JuliaLang/julia/issues/265">issue 265</a>, possibly the most infamous issue ever in Julia, and solved five years later, in <a href="https://github.com/JuliaLang/julia/pull/17057">PR 17057</a> for Julia 0.6.
    
</table>
 <table class=fndef  id="fndef:2">
    <tr>
        <td class=fndef-backref ><a href="#fnref:2">[2]</a>
        <td class=fndef-content >This is closely analogous to type piracy, but note that type piracy is about <em>defining</em> methods for foreign functions using foreign types, whereas &quot;external codeinstances&quot; &#40;i.e. foreign methodinstances&#41; are created when you simply <em>call</em> methods with such function signatures. Creating such foreign methodinstances is completely legitimate and must be expected in most packages.
    
</table>
</p>
<div class=page-foot >
  <div class=copyright >
    Jakob Nybo Nissen. Last modified: February 09, 2025. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>