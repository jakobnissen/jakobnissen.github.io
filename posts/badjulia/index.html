<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/basic.css"> <link rel=icon  href="/assets/favicon.png"> <title>What&#39;s bad about Julia?</title> <header> <div class=blog-name ><a href="/">viralinstruction</a></div> <nav> <ul> <li><a href="/">Home</a> <li><a href="/about/">About</a> </ul> <img src="/assets/hamburger.svg" id=menu-icon > </nav> </header> <div class=franklin-content ><h1 id=whats_bad_about_julia ><a href="#whats_bad_about_julia" class=header-anchor >What&#39;s bad about Julia?</a></h1> <p><em>Written 2021-07-25, updated 2021-07-25</em></p> <p>Julia is my favorite programming language. More than that actually, perhaps I&#39;m a bit of a fanboy. Sometimes, though, the ceaseless celebration of Julia by fans like me can be a bit too much. It papers over legitimate problems in the language, hindering progress. And from an outsider perspective, it&#39;s not only insufferable &#40;I would guess&#41;, but also obfuscates the true pros and cons of the language. Learning why you may <em>not</em> want to choose to use a tool is just as important as learning why you may.</p> <p>This post is about all the major disadvantages of Julia. Some it will just be rants about things I particularly don&#39;t like - hopefuly they will be informative, too. A post like this is necessarily subjective: Some people believe Julia&#39;s lack of a Java-esque OOP is a design mistake. I don&#39;t, so the post won&#39;t go into that.</p> <h2 id=table_of_contents ><a href="#table_of_contents" class=header-anchor >Table of contents</a></h2> <div class=franklin-toc ><ol><li><a href="#table_of_contents">Table of contents</a><li><a href="#compile_time_latency">Compile time latency</a><li><a href="#large_memory_consumption">Large memory consumption</a><li><a href="#julia_cant_easily_integrate_into_other_languages">Julia can&#39;t easily integrate into other languages</a><li><a href="#the_subtyping_system_works_poorly">The subtyping system works poorly</a><li><a href="#the_iterator_protocol_is_awful">The iterator protocol is awful</a><li><a href="#weak_static_analysis">Weak static analysis</a><li><a href="#unstable_language">Unstable language</a><li><a href="#immature_ecosystem">Immature ecosystem</a><li><a href="#no_concrete_inheritance">No concrete inheritance</a><li><a href="#unpolished_trait_system">Unpolished trait system</a><li><a href="#abstract_inheritance_is_not_very_useful">Abstract inheritance is not very useful</a><li><a href="#lack_of_static_analysis">Lack of static analysis</a><li><a href="#unstable_language__2">Unstable language</a><li><a href="#unstable_performance">Unstable performance</a><li><a href="#immature_ecosystem__2">Immature ecosystem</a></ol></div> <h2 id=compile_time_latency ><a href="#compile_time_latency" class=header-anchor >Compile time latency</a></h2> <p>The very first thing you learn about Julia is that it&#39;s unresponsive. You open the REPL, type in something trivial like <code>julia&gt; sin&#40;0.96^5&#41;</code>, and see a <em>noticable</em> lag before the answer appears. As far as first impressions go, that isn&#39;t exactly great, especially for a language touted for its speed.</p> <p>What&#39;s happening is that Julia is compiling <code>sin</code> - and also much of the code related to the REPL itself - first time you use it. This causes the lag we call <em>compile time latency</em>. Hence, the effect is even larger if we pull in new code from external packages: A small script that uses the packages <code>BioSequences</code> and <code>FASTX</code> may have a 2 second latency, even if the computation itself takes microseconds.</p> <p>And it can get worse, still. Among Julians, latency is often referred to as TTFP: <em>Time To First Plot</em>. Graphical plotting became the posterboy for this problem because plotting involves a large amount of code that does relatively little work. Importing <code>Plots</code> and plotting the simplest line plot takes 8 seconds. However, being the posterboy for latency, Plots have gotten a lot of attention and engineering effort to reduce its latency, so it&#39;s hardly the worst package. Packages like <code>Turing</code> or <code>ApproxFun</code> may add half a minute to latency - <code>Turing</code> took 40 seconds to start up on my laptop.</p> <p>So: How bad is this, really?</p> <p>Well, it depends on what you use Julia for. Remember, the latency is a one-time cost every time you start a Julia process. If you&#39;re a data scientist who works for hours on end in a Jupyter notebook, ten or even 40 seconds of startup time is merely a small annoyance. I&#39;m in that category, broadly. When I start Julia, it rarely takes less than a few minutes before I shut down. But some tasks and use cases rely on running lots of short Julia processes. These simply become impossible. For example, the latency makes Julia a complete non-starter for:</p> <ul> <li><p>Simple Unix commandline tools such as <code>cd</code>, <code>ripgrep</code> or <code>ls</code></p> <li><p>Settings where responsiveness is key, say software in a self-driving car or airplane</p> <li><p>Small composable scripts, e.g. as used in <a href="https://snakemake.readthedocs.io/en/stable/">Snakemake</a> workflows</p> </ul> <p>The latency also forces specific workflows for Julia users and developers. When using Python or Rust, you may be used to running some tests from command line, modifying a source file in the editor, then re-running the tests until they work. This workflow is not feasible in Julia - instead, you are essentially forced to into <em>REPL driven development</em>, where you have a single Julia session you keep open while modifying your code and observing the results.</p> <p>Julias latency <em>is</em> improving, and there <em>are</em> hoops you can jump through to mitigate this problem somewhat. But the problem is fundamentally unsolvable, because it&#39;s built into Julia on a basic design level. So, before learning Julia, ask yourself if this is a dealbreaker for you.</p> <h2 id=large_memory_consumption ><a href="#large_memory_consumption" class=header-anchor >Large memory consumption</a></h2> <p>This one&#39;s pretty easy to demonstrate:</p> <pre><code class="julia hljs">$ /usr/bin/time -f <span class=hljs-string >&quot;%M&quot;</span> julia hello_world.jl
Hello, world!
<span class=hljs-number >231316</span></code></pre> <p>Yep, 231 MB memory consumption for a hello-world script. Julia&#39;s runtime is <em>enormous</em> - these megabytes are not just used by Julias compiler, it apparently pre-allocates BLAS buffers, just in case the user wants to multiply matrices in their hello-world script, you know. Forget the latency, a background consumption of 231 MB completely excludes usign Julia for anything but application-level programs running on a PC or a compute cluster. For anything else, be it mobile, embedded, daemon processes, etc, you&#39;ll need to use something else.</p> <h2 id=julia_cant_easily_integrate_into_other_languages ><a href="#julia_cant_easily_integrate_into_other_languages" class=header-anchor >Julia can&#39;t easily integrate into other languages</a></h2> <p>Another consequence of Julia&#39;s massive runtime is that it makes it annoying to call into Julia from other languages. If your Python script needs to rely on Julia, you&#39;ll need to pay up front: Both the latency, <em>and</em> the 200-something megabytes.</p> <p>Compare this to a static language like C, where you can compile a C lib to a binary that other programs simply calls into. Julians are usually very proud of the large amount of code sharing and code reuse in the Julia community, but it&#39;s worth noting that this sharing stops abruptly at the language barrier: We might be able to use a Rust library, but no-one would use a Julia library if they could avoid it. So if you want to code up some universally used library, you better go with a static language.</p> <h2 id=the_subtyping_system_works_poorly ><a href="#the_subtyping_system_works_poorly" class=header-anchor >The subtyping system works poorly</a></h2> <ul> <li><p>What IS an abstract type - semantics or interface?</p> <li><p>if semantics, why? what does it give you? what guarantees? provide little benefit</p> <li><p>if interface: poorly documented, no enforcement.</p> <li><p>One-shot gun.</p> <li><p>You get the good parts AND the bad ones. With traits, there will be more traits so people can pick and choose.</p> </ul> <h2 id=the_iterator_protocol_is_awful ><a href="#the_iterator_protocol_is_awful" class=header-anchor >The iterator protocol is awful</a></h2> <h2 id=weak_static_analysis ><a href="#weak_static_analysis" class=header-anchor >Weak static analysis</a></h2> <h2 id=unstable_language ><a href="#unstable_language" class=header-anchor >Unstable language</a></h2> <h2 id=immature_ecosystem ><a href="#immature_ecosystem" class=header-anchor >Immature ecosystem</a></h2> <h2 id=no_concrete_inheritance ><a href="#no_concrete_inheritance" class=header-anchor >No concrete inheritance</a></h2> <ul> <li><p>Example: BiDict - implement in Python through inheritance in Julia though...</p> <li><p>Mention AbstractArray as the single really good abstract interfact </p> </ul> <p>that keeps getting mentioned which quickly become extremely complex &#40;issue #37790&#41;</p> <h2 id=unpolished_trait_system ><a href="#unpolished_trait_system" class=header-anchor >Unpolished trait system</a></h2> <ul> <li><p>Leads to endless wrapping, which again leads to a reliance on traits,</p> <li><p>No easy fix, even in principle. It&#39;s unclear what the best approach is.</p> </ul> <h2 id=abstract_inheritance_is_not_very_useful ><a href="#abstract_inheritance_is_not_very_useful" class=header-anchor >Abstract inheritance is not very useful</a></h2> <p>&#40;expand on the two above points&#41;</p> <ul> <li><p>Abstract inheritance &#40;AI&#41; requires you to know beforehand the abstract interface,</p> </ul> <p>but this is often not possible. You can&#39;t post-hoc inherit.</p> <ul> <li><p>Example: People disagree on what an AbstractChar / Number / AbstractSet even is.</p> <li><p>These are enforced only with docs, which is notoriously unreliable.</p> <li><p>Assumes interfaces are nested like a tree, but this is often not the case.</p> <li><p>When not a tree, forced to use unions / traits, which are half baked</p> <li><p>Example: Big unions, like SparseArrays._StridedOrTriangularMatrix</p> </ul> <h2 id=lack_of_static_analysis ><a href="#lack_of_static_analysis" class=header-anchor >Lack of static analysis</a></h2> <ul> <li><p>Having tried Rust, it&#39;s harder to defend.</p> <li><p>Should be able to be added in a non-breaking way.</p> <li><p>Even something simple as typos dont get caught</p> <li><p>Coupled with latency, that&#39;s pretty annoying</p> <li><p>JET does sort of solve the problem, but as long as ecosystem isn&#39;t type stable,</p> </ul> <p>any signal drowns in the noise.</p> <h2 id=unstable_language__2 ><a href="#unstable_language__2" class=header-anchor >Unstable language</a></h2> <ul> <li><p>High number of bugs - look at GitHub</p> <li><p>Personal experience: Often hit edge cases or compiler quirks</p> </ul> <h2 id=unstable_performance ><a href="#unstable_performance" class=header-anchor >Unstable performance</a></h2> <ul> <li><p>Due to type instabilities not being breaking, they can happen.</p> </ul> <h2 id=immature_ecosystem__2 ><a href="#immature_ecosystem__2" class=header-anchor >Immature ecosystem</a></h2> <ul> <li><p>Lack of niche packages in science &#40;e.g. bioinformatics&#41;</p> </ul> <div class=page-foot > <div class=copyright > Jakob Nybo Nissen. Last modified: July 25, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div>