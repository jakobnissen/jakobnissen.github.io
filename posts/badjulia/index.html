<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/basic.css"> <link rel=icon  href="/assets/v.svg"> <title>What&#39;s bad about Julia?</title> <header> <div class=blog-name ><a href="/">viralinstruction</a></div> <nav> <ul> <li><a href="/">Home</a> <li><a href="/about/">About</a> </ul> <img src="/assets/hamburger.svg" id=menu-icon > </nav> </header> <div class=franklin-content ><h1 id=whats_bad_about_julia ><a href="#whats_bad_about_julia" class=header-anchor >What&#39;s bad about Julia?</a></h1> <p><em>Written 2021-07-25, updated 2021-07-27</em></p> <p>Julia is my favorite programming language. More than that actually, perhaps I&#39;m a bit of a fanboy. Sometimes, though, the ceaseless celebration of Julia by fans like me can be a bit too much. It papers over legitimate problems in the language, hindering progress. And from an outsider perspective, it&#39;s not only insufferable &#40;I would guess&#41;, but also obfuscates the true pros and cons of the language. <a href="https://matklad.github.io/2020/09/20/why-not-rust.html">Learning why you may <em>not</em> want to choose to use a tool</a> is just as important as learning why you may.</p> <p>This post is about all the major disadvantages of Julia. Some of it will just be rants about things I particularly don&#39;t like - hopefully they will be informative, too. A post like this is necessarily subjective. For example, some people believe Julia&#39;s lack of a Java-esque OOP is a design mistake. I don&#39;t, so the post won&#39;t go into that.</p> <h2 id=table_of_contents ><a href="#table_of_contents" class=header-anchor >Table of contents</a></h2> <div class=franklin-toc ><ol><li><a href="#table_of_contents">Table of contents</a><li><a href="#compile_time_latency">Compile time latency</a><li><a href="#large_memory_consumption">Large memory consumption</a><li><a href="#julia_cant_easily_integrate_into_other_languages">Julia can&#39;t easily integrate into other languages</a><li><a href="#weak_static_analysis">Weak static analysis</a><li><a href="#the_core_language_is_unstable">The core language is unstable</a><li><a href="#the_ecosystem_is_immature">The ecosystem is immature</a><li><a href="#the_type_system_works_poorly">The type system works poorly</a><ol><li><a href="#you_cant_extend_existing_types_with_data">You can&#39;t extend existing types with data</a><li><a href="#abstract_interfaces_are_unenforced_and_undiscoverable">Abstract interfaces are unenforced and undiscoverable</a><li><a href="#subtyping_is_an_all-or-nothing_thing">Subtyping is an all-or-nothing thing</a></ol><li><a href="#the_iterator_protocol_is_weird_and_too_hard_to_use">The iterator protocol is weird and too hard to use</a><ol><li><a href="#the_protocol">The protocol</a><li><a href="#the_problem">The problem</a></ol><li><a href="#functional_programming_primitives_are_not_well_designed">Functional programming primitives are not well designed</a></ol></div> <h2 id=compile_time_latency ><a href="#compile_time_latency" class=header-anchor >Compile time latency</a></h2> <p>The very first thing you learn about Julia is that it&#39;s unresponsive. You open your favorite IDE, launch a Julia REPL, start typing... and see a <em>noticable</em> lag before any text appears. As far as first impressions go, that isn&#39;t exactly great, especially for a language touted for its speed.</p> <p>What&#39;s happening is that Julia is compiling the code needed for its REPL and its integration with your editor. This &quot;runtime&quot; compilation causes the lag we call <em>compile time latency</em>. Hence, the effect is even larger if we pull in new code from external packages: A small script that uses the packages <code>BioSequences</code> and <code>FASTX</code> may have a 2 second latency, even if the computation itself takes microseconds.</p> <p>And it can get worse, still. Among Julians, latiency is often referred to as TTFP: <em>Time To First Plot</em>. Graphical plotting became the posterboy for this problem because plotting involves a large amount of code that does relatively little work. Importing <code>Plots</code> and plotting the simplest line plot takes 8 seconds. However, being the posterboy for latency, Plots have gotten a lot of attention and engineering effort to reduce its latency, so it&#39;s hardly the worst package. Packages like <code>Turing</code> or <code>ApproxFun</code> may add half a minute to latency - <code>Turing</code> took 40 seconds to start up on my laptop. I&#39;ve heard of organizations whose codebase is in Julia where it takes 5 minutes to start a Julia process and load their packages.</p> <p>So: How bad is this, really?</p> <p>Well, it depends on what you use Julia for. Remember, the latency is a one-time cost every time you start a Julia process. If you&#39;re a data scientist who works for hours on end in a Jupyter notebook, ten or even 40 seconds of startup time is merely a small annoyance. I&#39;m in that category, broadly. When I start Julia, it rarely takes less than a few minutes before I shut down - and the Julia programs I run from command line takes minutes to complete, too. But some tasks and use cases rely on running lots of short Julia processes. These simply become impossible. For example, the latency makes Julia a complete non-starter for:</p> <ul> <li><p>Simple Unix commandline tools such as <code>ripgrep</code> or <code>ls</code></p> <li><p>Settings where responsiveness is key, say software in a self-driving car or airplane</p> <li><p>Small composable scripts, e.g. as used in <a href="https://snakemake.readthedocs.io/en/stable/">Snakemake</a> workflows</p> </ul> <p>The latency also forces specific workflows for Julia users and developers. When using Python or Rust, you may be used to running some tests from command line, modifying a source file in the editor, then re-running the tests from command line until they work. This workflow is not feasible in Julia, because latency would occur every time you invoked Julia from command line. Instead, you are essentially forced to into <em>REPL driven development</em>, where you have a single Julia session you keep open alongside your editor, and interact with Julia &#40;e.g. running tests or code analysis&#41; only thorugh that REPL.</p> <p>Julias latency <em>is</em> improving, and there <em>are</em> hoops you can jump through to mitigate this problem somewhat. But the problem is fundamentally unsolvable, because it&#39;s built into Julia on a basic design level. So, before learning Julia, ask yourself if this is a dealbreaker for you.</p> <h2 id=large_memory_consumption ><a href="#large_memory_consumption" class=header-anchor >Large memory consumption</a></h2> <p>This one&#39;s pretty easy to demonstrate:</p> <pre><code class="julia hljs">$ /usr/bin/time -f <span class=hljs-string >&quot;%M&quot;</span> julia hello_world.jl
Hello, world!
<span class=hljs-number >148724</span></code></pre> <p>Yep, ~150 MB memory consumption for a hello-world script. Julia&#39;s runtime is <em>enormous</em> - these megabytes are not just used by Julias compiler, it apparently pre-allocates BLAS buffers, just in case the user wants to multiply matrices in their hello-world script, you know. Forget the latency, a background consumption of 150 MB completely excludes using Julia for anything but application-level programs running on a PC or a compute cluster. For anything else, be it mobile, embedded, daemon processes, etc, you&#39;ll need to use something else.</p> <p>In fact, even for desktop-level applications, consuming 150 MB on the Julia runtime is pushing it. Think of all the hate Electron gets for wasting resources. <em>Every</em> Julia program is in the same ballpark as Electron in this regard. A command-line calculator written in Julia consumes more memory than the 2003 video game <em>Command &amp; Conquer: Generals</em>.</p> <h2 id=julia_cant_easily_integrate_into_other_languages ><a href="#julia_cant_easily_integrate_into_other_languages" class=header-anchor >Julia can&#39;t easily integrate into other languages</a></h2> <p>Another consequence of Julia&#39;s massive runtime is that it makes it annoying to call into Julia from other languages. If your Python script needs to rely on Julia, you&#39;ll need to pay up front: Both the latency, <em>and</em> the 150-ish megabytes.</p> <p>Compare this to a static language like C, where you can compile a C lib to a binary that other programs simply calls into. Julians are usually very proud of <a href="https://www.youtube.com/watch?v&#61;kc9HwsxE1OY">the large amount of code sharing and code reuse</a> in the Julia community, but it&#39;s worth noting that this sharing stops abruptly at the language barrier: We might be able to use a Rust library in Julia with little friction, but no-one would use a Julia library if they could avoid it. So if you want to code up some universally used library, you better go with a static language.</p> <h2 id=weak_static_analysis ><a href="#weak_static_analysis" class=header-anchor >Weak static analysis</a></h2> <p>This is one point where I&#39;ve changed perspective after having tried coding Rust. Before learning Rust, when I only knew Python and Julia I would have said something like:</p> <blockquote> <p>Sure, static analysis is useful. But to ensure program correctness, you need tests anyway, and these tests will catch the vast majority of what would be compile-time errors. The small safety you lose in a dynamic language is more than made up by the time saved, which you can use to write better tests.</p> </blockquote> <p>How silly, past me, if only you knew&#33; See, I taught myself Rust by doing the <a href="https://github.com/jakobnissen/advent2020">Advent of Code 2020</a> in Rust. Being a neophyte, I was so bad at Rust that I had more than one compiler error per line of code on average. <em>Everything</em> was hard. And yet, for about two-thirds of the challenges, the <em>first</em> time the program compiled, it gave the correct answer.</p> <p>That was astounding to me. Working with Python or Julia, I expected the program to crash. Programs always crash at first, right? Well, they do in Julia until you&#39;ve found the bugs by hitting them, and fixed them one by one. In fact, for me it was part of the development workflow, iteratively write the solution, run it, watch where it crashes, fix it, repeat. The idea that you could just write the right program on the first try was wild. The experience was <em>not</em> that my program became more safe in the sense that I could ship it without sweat on my brow. No, it was that it <em>just worked</em>, and I could completely skip the entire debugging process that is core to the development experience of Julia, because I had gotten all the errors at compile time.</p> <p>And this was for small scripts. I can only imagine the productivity boots that static analysis gives you for larger projects when you can safely refactor, because you know immediately if you do something wrong.</p> <p>Back to Julia: It lies somewhere in between Python and Rust in terms of static analysis and safety. You <em>can</em> add type annotations to your functions, but the errors still only appear at runtime, and it&#39;s generally considered un-idiomatic to use too many type annotations, <a href="#the_type_system_works_poorly">with good reason</a>. <a href="https://github.com/julia-vscode/StaticLint.jl">Linting</a> and <a href="https://github.com/aviatesk/JET.jl">static analysis</a> for Julia are slowly appearing and improving, but compared to Rust they catch just a small fraction of errors. When writing generic package code where types are mostly indeterminate until runtime, they can&#39;t do much type analysis.</p> <p>Another issue with static analysis in Julia is that, because writing un-inferrable code is a completely valid &#40;if inefficient&#41; coding style, there is a lot of code that simply can&#39;t be statically analysed. Similarly, you can have a Julia package whose dynamic style causes tonnes of &quot;issues&quot; according to the static analyzer, which nonetheless work fine. If your package depends on such a package, your static analysis will be flooded with false positives originating from the third-party code.</p> <p>I&#39;m a big fan of these tools, but honestly, in their current state, you can rely on the linter to catch typos or wrong type signatures, and on the static analyzer to analyze specific function calls you ask it to... but that&#39;s about it.</p> <p>Is it unfair to criticise a <em>dynamic</em> language for not having <em>static</em> analysis? Isn&#39;t that implicit? Perhaps. But this post is about the weaknesses of Julia, and no matter how you justify it, poor static analysis is most definitely a weakness.</p> <h2 id=the_core_language_is_unstable ><a href="#the_core_language_is_unstable" class=header-anchor >The core language is unstable</a></h2> <p>Julia released 1.0 in 2018, and has been committed to no breakage since then. So how can I say the language is unstable?</p> <p>Instability isn&#39;t just about breaking changes. It&#39;s also about bugs and incorrect documentation. And here, Julia is pretty bad. Having used Julia since just before 1.0, I run into bugs in the core language regularly. Not often, but perhaps once every couple of months. I can&#39;t recall ever having run into a bug in Python.</p> <p>If you doubt it, take a look at the <a href="https://github.com/JuliaLang/julia/issues?q&#61;is&#37;3Aissue&#43;is&#37;3Aopen&#43;label&#37;3Abug">open issues marked as bugs</a>. Some of these are transient bugs on master, but there are <em>many</em>, <em>many</em> old bugs you can still go in and trigger from the REPL on the stable Julia release. Here&#39;s one <a href="https://github.com/JuliaLang/julia/issues/36605">I reported about a year ago</a>, and which still hasn&#39;t been fixed:</p> <pre><code class="julia hljs">julia&gt; open(read, <span class=hljs-string >&quot;/home/jakob/Documents&quot;</span>) <span class=hljs-comment ># yes, a directory</span>
<span class=hljs-built_in >UInt8</span>[]</code></pre> <p>I don&#39;t think it&#39;s because the Julia devs are careless, or Julia isn&#39;t well tested. It&#39;s just a matter of bugs continuously being discovered because Julia is relatively young software. As it matures and stabilizes post 1.0, the number of bugs have gone down and will continue to do so in the future. But until it does, don&#39;t expect mature, stable software when using Julia.</p> <p>There is, however, also the issue of unstable performance, where Julia is a uniquely awkward situation. Other dynamic languages are slow, and people using them write code expecting them to be slow. Static languages are fast, because the compiler has full type information during the compilation process. If the compiler can&#39;t infer the type of something, the program won&#39;t compile. Importantly, because an inference failure in static languages causes the compilation to fail, <em>the compiler&#39;s inference is part of the API, and must remain stable</em>. Not so in Julia.</p> <p>In Julia, what the compiler knows about your code and the optimizations it does is a pure implementation detail - at long as it produces the correct result. Even in situations where <em>nothing</em> can be inferred about the types Julia will run and produce the correct result, just hundreds of times slower. That means that a compiler change that causes a failure of inference and a 100x performance regression is not a breaking change. So, these happens.</p> <p>I mean, don&#39;t get me wrong, they don&#39;t happen <em>often</em>, and they usually only affect part of your program, so the regression is rarely that dramatic. The Julia team really tries to avoid regressions like that, and they&#39;re usually picked up and fixed on the master branch of Julia before they make it to any release. Still, if you&#39;ve maintained a few Julia packages, I bet it has happened to you more than once.</p> <h2 id=the_ecosystem_is_immature ><a href="#the_ecosystem_is_immature" class=header-anchor >The ecosystem is immature</a></h2> <p>A more important consequence of Julia being a young, immature language is that the package ecosystem is similarly immature. Compared to the core language, which have a huge number of users, and more developers, the ecosystem settles more slowly. This has several consequences for Julia:</p> <p>First, compared to established languages, lots of packages are missing. Especially if you work in a niche subject, as most scientists do, you are much more likely to find a Python or R package to fit your needs than a Julia package. This situation will obviously improve over time, but right now, Julia is still quite far behind.</p> <p>You&#39;re also much more likely to find outdated or unmaintained packages in Julia. This is not because Julia packages tend to fall into disrepair more quickly than other languages, I think, but rather because packages which has already existed for 20 years are more likely to last another five more years than packages that have existed for two years. It&#39;s only been three years since Julia 1.0 came out, so if you find a blog post from 2015, any posted Julia code is unlikely to work, and the packages have probably released several breaking changes since then. In comparison, the Python package Numpy has been around five times longer than Julia 1.0&#33;</p> <p>In software ecosystems, it also takes a while for effort to consolidate to well-known packages. In Python, everybody knows, for example, to use <code>pandas</code> when working with dataframes. It has become the de-facto standard. And if it is to be dethroned, any contender must compare favorably against <code>pandas</code>, which means it must itself be a solid, well-used package. In Julia, it&#39;s not too rare to want a functionality and find three packages that do it in slightly different ways, all of them immature and light on features.</p> <p>Perhaps most critically, the developer tooling surrounding Julia is also immature, with lots of basic functionality missing. This is also a consequence of the ecosystem simply not being mature enough, with too little development effort behind it &#40;notably, no large companies have made large contributions to Julia, unlike every other language I know of&#41;. Here are a few examples, haphazardly chosen:</p> <ul> <li><p>Julia&#39;s built-in <code>Test</code> package is barebones, and does not offer setup and teardown of tests, nor the functionality to only run a subset of the full test suite. This is by design, but there does not exist a common go-to testing package that offers what the stdlib package lacks.</p> <li><p>The editor experience is not great with Julia. It&#39;s getting better, but with the foremost Julia IDE developed by a few people in their spare time, it has all the crashes, slowness and instability you would expect.</p> <li><p>Static analysis is brand new, and feels like it hasn&#39;t yet settled into its final form. It also has no IDE integration.</p> <li><p>There is no common framework for benchmarking and profiling Julia code. In a single session, you may analyze the same function with <code>BenchmarkTools</code>, <code>@allocated</code>, <code>Profile</code>, <code>JET</code>, <code>JETTest</code>, <code>@code_native</code> and <code>Cthulhu</code>, which each has to be loaded and launched individually. This issue is particularly notable when a new user faces performance issues and ask a Julia forum &quot;what should I do&quot;, and get 10 <em>different</em> answers, each concerning one specific sub-analysis that may cast light on one particular cause of performance problems. This is a huge time sink, and not a great user experience. It should be possible to gather several of these tools in a single analysis package, but it has not yet been done.</p> </ul> <h2 id=the_type_system_works_poorly ><a href="#the_type_system_works_poorly" class=header-anchor >The type system works poorly</a></h2> <p>This is the most controversial of my problems with Julia. People who don&#39;t know Julia have no idea what I mean when I say the subtyping system is bad, and people who <em>do</em> know Julia are unlikely to agree with me. I&#39;ll give a brief recap of how the system works for anyone not familiar:</p> <p>In Julia, types can be either <em>abstract</em> or <em>concrete</em>. Abstract types are considered &quot;incomplete&quot;. They can have subtypes, but they cannot hold any data fields or be instantiated - they are incomplete, after all. Concrete types can be instantiated and may have data, but cannot be subtyped since they are final. Here is an imaginary example:</p> <pre><code class="julia hljs"><span class=hljs-comment ># Abstract type subtyping BioSequence (itself abstract)</span>
<span class=hljs-keyword >abstract type</span> NucleotideSequence &lt;: BioSequence <span class=hljs-keyword >end</span>

<span class=hljs-comment ># Concrete types with fields subtyping NucleotideSequence</span>
<span class=hljs-comment ># cannot be subtyped!</span>
<span class=hljs-keyword >struct</span> DNASequence &lt;: NucleotideSequence
    x::<span class=hljs-built_in >Vector</span>{DNA}
<span class=hljs-keyword >end</span></code></pre> <p>You can define methods for abstract types, which are inherited by all its subtypes &#40;that is, <em>behaviour</em> can be inherited, but not <em>data</em>&#41;. But if a concrete type define the same method, that will overwrite the abstract one:</p> <pre><code class="julia hljs"><span class=hljs-comment ># Generic function, is slow</span>
<span class=hljs-keyword >function</span> print(io::<span class=hljs-built_in >IO</span>, seq::NucleotideSequence)
    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> seq
        print(io, i)
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span>

<span class=hljs-comment ># Specialized function, overwrites generic</span>
<span class=hljs-keyword >function</span> print(io::<span class=hljs-built_in >IO</span>, seq::DNASequence)
    write(io, seq.x) <span class=hljs-comment ># optimized write implementation</span>
<span class=hljs-keyword >end</span></code></pre> <p>So you can create type hierarchies, implement generic fallback methods, and overwrite them whenever you want. Neat&#33; What&#39;s not to like? Well...</p> <h3 id=you_cant_extend_existing_types_with_data ><a href="#you_cant_extend_existing_types_with_data" class=header-anchor >You can&#39;t extend existing types with data</a></h3> <p>Say you implement some useful <code>MyType</code>. Another package thinks it&#39;s really neat and wants to extend the type. Too bad, that&#39;s just not possible - <code>MyType</code> is final and can&#39;t be extended. If the original author didn&#39;t add an abstract supertype for <code>MyType</code> you&#39;re out of luck. And in all probability, the author didn&#39;t. After all, good coders usually follow the <a href="https://en.wikipedia.org/wiki/You_aren&#37;27t_gonna_need_it">YAGNI</a> principle: Don&#39;t pre-emptively implement what you don&#39;t need.</p> <p>In e.g. Python, you are not going to run into types you want to subclass, but can&#39;t. You can subclass whatever you damn well please. In Rust, the problem is not even recognizable: Any type you write can freely derive traits and is not at all constrained by where it is placed in the type hierarchy, because there <em>is</em> no type hierarchy.</p> <h3 id=abstract_interfaces_are_unenforced_and_undiscoverable ><a href="#abstract_interfaces_are_unenforced_and_undiscoverable" class=header-anchor >Abstract interfaces are unenforced and undiscoverable</a></h3> <p>Suppose, on the other hand, you find out the author <em>did</em> actually add <code>AbstractMyType</code>. Then you can subtype it:</p> <pre><code class="julia hljs"><span class=hljs-keyword >struct</span> YourType &lt;: AbstractMyType
    [ stuff ]
<span class=hljs-keyword >end</span></code></pre> <p>... and now what? What do you need to implement? What does the abstract type require? What does it guarantee? Julia offers absolutely no way of finding out what the abstract interface is, or how you conform to it. In fact, even in Base Julia, fundamental types like <code>AbstractSet</code>, <code>AbstractChannel</code>, <code>Number</code> and <code>AbstractFloat</code> are just not documented. What actually <em>is</em> a <code>Number</code>, in Julia? I mean, we know what a number is conceptually, but what are you opting in to when you subtype <code>Number</code>? What do you promise? Who knows? Do even the core developers know? I doubt it.</p> <p>A few abstract types in Julia <em>are</em> well documented, most notably <code>AbstractArray</code> and its abstract subtypes, and it&#39;s probably no coindidence that Julia&#39;s array ecosystem is so good. But this is a singular good example, not the general pattern. Ironically, this exception is often held up as an example of why the Julia type system <em>works well</em>.</p> <p>Here is a fun challenge for anyone who thinks &quot;it can&#39;t be that bad&quot;: Try to implement a <code>TwoWayDict</code>, an <code>AbstractDict</code> where if <code>d&#91;a&#93; &#61; b</code>, then <code>d&#91;b&#93; &#61; a</code>. In Python, which has inheritance, this is trivial. You simply subclass <code>dict</code>, overwrite a handful of its methods, and everything else works. In Julia, you have to define its data layout first - quite a drag, since dictionaries have a complicated structure &#40;remember, you can&#39;t inherit data&#33;&#41;. The data layout can be solved by creating a type that simply wraps a <code>Dict</code>, but the real pain of the implementation come when you must somehow figure out everything <code>AbstractDict</code> promises &#40;good luck&#33;&#41; and implement that.</p> <h3 id=subtyping_is_an_all-or-nothing_thing ><a href="#subtyping_is_an_all-or-nothing_thing" class=header-anchor >Subtyping is an all-or-nothing thing</a></h3> <p>Another problem with relying on subtyping for behaviour is that each type can only have one supertype, and it inherits <em>all</em> of its methods. Often, that turns out to not be what you want: New types often has properties of several interfaces: Perhaps they are set-like, iterable, callable, printable, etc. But no, says Julia, pick <em>one</em> thing. To be fair, &quot;iterable&quot;, &quot;callable&quot; and &quot;printable&quot; are so generic and broadly useful they are not implemented using subtyping in Julia - but doesn&#39;t that say something?</p> <p>In Rust, these properties are implemented through traits instead. Because each trait is defined independently, each type faces a smorgasbord of possibilities. It can choose <em>exactly</em> what it can support, and nothing more. It also leads to more code reuse, as you can e.g. simply derive <code>Copy</code> and get it without having to implement it. It also means there is an incentive to create &quot;smaller&quot; traits. In Julia, if you subtype <code>AbstractFoo</code>, you opt in to a potentially huge number of methods. In contrast, it&#39;s no problem to create very specific traits that concerns only a few - or one - method.</p> <p>Julia <em>does</em> have traits, but they&#39;re half-baked, not supported on a language level, and haphazardly used. They are usually implemented through multiple dispatch, which is also annoying since it can make it difficult to understand what is actually being called. Julia&#39;s broadcasting mechanism, for example, is controlled primarily through traits, and just finding the method ultimately being called is a pain.</p> <p>Also, since so much of Julia&#39;s behaviour is controlled through the type of variables instead of traits, people are tempted to use wrapper types if they want type <code>A</code> to be able to behave like type <code>B</code>. But those are <a href="https://github.com/JuliaLang/julia/issues/37790">a terrible idea</a>, since it only moves the problem and in fact makes it worse: You now have a new wrapper type you need to implement everything for, and even if you do, the wrapper type is now of type <code>B</code>, and doesn&#39;t have access to the methods of <code>A</code>&#33;</p> <p>A good example of the subtyping system not working is Julia&#39;s standard library <code>LinearAlgebra</code>. This package uses both wrapper types and traits to try to overcome the limitations of the type system, and suffers from both the workarounds. But an even clearer example of the failure of the type system is its use of <em>big unions</em>, that is, functions whose type signature has arguments of the type &quot;A or B or C or D or E or ...&quot;. These typically appear in code when you need to add a method to an object, and then discover that the sets of types you need to implement it for doesn&#39;t fit into the type hierarchy as a single supertype. Why is it simply assumed that behaviour was strictly <a href="https://en.wikipedia.org/wiki/Monophyly">monophyletic?</a>. Besides how unwieldly they are, uninons are also un-extendable. And those unions in even Base Julia can get out of control: If you have Julia at hand, try to type in <code>LinearAlgebra.StridedVecOrMat</code> and watch the horror. The use of such an abomination is a symptom of an unsolved underlying problem with the type system.</p> <p>The consensus on idiomatic Julia seem to be slowly drifting away from leaning on its type system to specify constraints, and towards ducktyping and traits. I essentially see this as the community implicitly beginning to acknowledge the problems of the type system and trying to avoid it where possible. All the individual gripes in the post about the system are well known, even if few people would grant the system as whole is poor. It has, however, been remarkably hard to provide good alternatives or solve the individual pain points. As Julia is maturing, there is less and less space to re-invent or enhance something as core as the type system.</p> <p>I expect that in the future, Julians will move even further towards Python-esque ducktyping. I predict that while there will arise packages that try to address some of these issues, they will be in disagreement about what to do, they will be niche, without good core language support, and therefore not really solve the problem.</p> <h2 id=the_iterator_protocol_is_weird_and_too_hard_to_use ><a href="#the_iterator_protocol_is_weird_and_too_hard_to_use" class=header-anchor >The iterator protocol is weird and too hard to use</a></h2> <h3 id=the_protocol ><a href="#the_protocol" class=header-anchor >The protocol</a></h3> <p>By &quot;the iterator protocol&quot;, I mean: How does a for loop work? The three languages I&#39;m familiar with, Python, Rust and Julia, all handle this slightly different. In Julia, the following code:</p> <pre><code class="julia hljs"><span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> x
    <span class=hljs-comment ># stuff</span>
<span class=hljs-keyword >end</span></code></pre> <p>lowers into something equivalent to:</p> <pre><code class="julia hljs">itval = iterate(x)
<span class=hljs-keyword >while</span> itval !== <span class=hljs-literal >nothing</span>
    i, state = itval
    <span class=hljs-comment ># stuff</span>
    itval = iterate(x, state)
<span class=hljs-keyword >end</span></code></pre> <p>This means that, to implement an iterator, you need to implement <code>iterate&#40;x&#41;</code> and <code>iterate&#40;x, state&#41;</code>. It should return <code>nothing</code> when the iteration is done, and <code>&#40;i, next_state&#41;</code> when it still has elements. By the way, you <em>also</em> need to implement a few traits, which Julia does not warn you about if you forget, or implement them wrongly. But <a href="#abstract_interfaces_are_unenforced_and_undiscoverable">I gripe about that elsewhere</a>.</p> <p>So: Why is it like that? Well, <a href="https://mikeinnes.github.io/2020/06/04/iterate.html">I&#39;m not the only one to wonder</a>. At least one of the reasons it was designed like that is that it makes the <code>iterate</code> function and the iterator itself <em>stateless</em>, since the state is stored in the local variable passed as an argument to the <code>iterate</code> function. It means you can&#39;t have bugs like this Python bug:</p> <pre><code class="python hljs"><span class=hljs-meta >&gt;&gt;&gt; </span><span class=hljs-built_in >iter</span> = (i+<span class=hljs-number >1</span> <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-number >3</span>))
<span class=hljs-meta >&gt;&gt;&gt; </span>length = <span class=hljs-built_in >sum</span>(<span class=hljs-number >1</span> <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-built_in >iter</span>)
<span class=hljs-meta >&gt;&gt;&gt; </span><span class=hljs-built_in >list</span>(<span class=hljs-built_in >iter</span>) <span class=hljs-comment ># oops!</span>
[]</code></pre> <h3 id=the_problem ><a href="#the_problem" class=header-anchor >The problem</a></h3> <p>First, you <em>absolutely</em> can have the same bug as in Python, because <em>some</em> iterators <em>are</em> stateful&#33; For example, if you read a file:</p> <pre><code class="julia hljs">julia&gt; lines = eachline(<span class=hljs-string >&quot;my_file.txt&quot;</span>);

julia&gt; n_lines = count(x -&gt; <span class=hljs-literal >true</span>, lines);

julia&gt; collect(lines)
<span class=hljs-built_in >String</span>[]</code></pre> <p>And since there is no way of knowing programatically &#40;and certainly not statically&#41; if an iterator is stateful, you better adopt a coding style that assumes all iterators are stateful, anyway.</p> <p>To be clear, the <em>problem</em> isn&#39;t that Julia has stateless iterators. Stateless iterators have advantages, they may in fact be superior and preferable where possible. The real problem is that <em>iteration is never stateless</em> - in a loop, there <em>must</em> always be state. When using stateless iterators, the problem of keeping track of the state is not solved, but simply moved elsewhere. Julia&#39;s iterators are &quot;stateless&quot; in the worst possible sense of the word: That the compiler and the language doesn&#39;t know about state, and therefore offloads the job of keeping track of it to the programmer. Reasoning about state across time is a famously hard problem in programming, and with Julia&#39;s iterators, you get to feel 100&#37; of that pain.</p> <p>Making the compiler&#39;s job easier by offloading work to the programmer is not how high-level languages are supposed to work&#33; The solution, at least not being a Julia developer, seems obvious. Iteration should instead lower to</p> <pre><code class="julia hljs">itr = iterator(x)
<span class=hljs-keyword >while</span> (i = next(itr)) !== <span class=hljs-literal >nothing</span>
    <span class=hljs-comment ># stuff</span>
<span class=hljs-keyword >end</span></code></pre> <p>This is how Rust and Python works, approximately. Notice the code is simpler than what Julia acutally lowers to. The big advantage, however, is that the state is stored in the <code>itr</code> object, and doesn&#39;t need to be manually handled or passed around by the person implementing the iterations. Interestingly, it already solves the problem of stateful iterators that Julia&#39;s solution is meant to address, since the iterator is reset on the call to <code>iterator</code>.</p> <p>What are the problems with passing around state with the current approach? Suppose you create an iterator that you need to process in two stages: First, you do some initialization with the first elements of the iterator. Perhaps it&#39;s an iterator of lines and you need to skip the header. After that, you iterate over the remaining arguments. You implement this as the functions <code>parse_header</code> and <code>parse_rest</code> In Julia, <em>you need to explicitly pass state</em> between the functions as an argument - not to mention all the boilerplate code it introduces because <code>parse_rest</code> now can&#39;t use a for loop to iterate, since that would &quot;restart&quot; the iterator. Well, <em>maybe</em> it would, who knows if it&#39;s stateless&#33;</p> <p>If you&#39;re a Julian reading this with scepticism, try implementing an interleaving iterator: It should take any number of iterators <code>x1, x2, ... xn</code> and produce a stream of their interleaved values: <code>x1_1, x2_x1, ... nx_1, x1_2 ... xn_m</code>. Easy peasy in Python, a headache in Julia because you have to juggle N states manually in the function. Or try re-implementing <code>zip</code> or a roundrobin iterator.</p> <h2 id=functional_programming_primitives_are_not_well_designed ><a href="#functional_programming_primitives_are_not_well_designed" class=header-anchor >Functional programming primitives are not well designed</a></h2> <p>I didn&#39;t really notice this until I tried Rust, and Julia&#39;s <code>Transducers</code> package, both of whom implements the foundations of functional programming &#40;by this I mean map, filter etc.&#41; way better than Julia itself does. This issue is not <em>one single</em> design problem, but rather a series of smaller issues about how Julia&#39;s iterators are just... generally not that well designed.</p> <ol> <li><p><code>map</code>, <code>filter</code> and <code>split</code> are eager, returning <code>Array</code>. There is <em>literally</em> no reason for this - it only makes the code slower and less generic. I can&#39;t think of a single upside - perhaps other than that it saves you typing <code>collect</code> once in a while. Newer versions of Julia introduced <code>Iterators.map</code> and <code>Iterators.filter</code> which <em>are</em> lazy, but using them means breaking backwards compatibility, and also, you have to use the ugly identifier <code>Iterators</code>. And for <code>split</code>, there is no such escape hatch - you just have to accept it&#39;s slow and unnecessarily allocating.</p> <li><p>Functional programming functions like <code>map</code> and <code>filter</code> can&#39;t take functions. That is, I cannot call <code>map&#40;f&#41;</code> and get a &quot;mapper&quot; function. I usually &quot;solve&quot; this by defining <code>imap&#40;f&#41; &#61; x -&gt; Iterators.map&#40;f, x&#41;</code> in the beginning of my files, but honestly, Julia&#39;s iterators should work like this by default.</p> <li><p>What do you think the method <code>eachline&#40;::String&#41;</code> does? Does it iterate over each line of a string? Haha, no, silly you. It interprets the string as a filename, tries to open the file, and returns an iterator over its lines. <em>What?</em> So, how do you actually iterate over the lines in a string? Well, you have to wrap the string in <code>IO</code> objects first. Yeah. that&#39;s another gripe, there is no such type as a <code>Path</code> in Julia - it just uses strings. Why not? I honestly don&#39;t know, other than perhaps the Julia devs wanted to get 1.0 out and didn&#39;t have time to implement them.</p> </ol> <p>But Jakob, you say, don&#39;t you know about Takafumi Arakaki&#39;s amazing <code>JuliaFolds</code> ecosystem which reimagines Julia&#39;s iterator protocol and functional programming and gives you everything you ask for? Yes I do, and it&#39;s the best thing since sliced bread, BUT this basic functionality simply <em>can&#39;t</em> be a package. It <em>needs</em> to be in Base Julia. For example, if I use Arakaki&#39;s packages to create an &quot;iterator&quot;, I can&#39;t iterate over it with a normal Julia for loop, because Julia&#39;s for loops lower to calls to <code>Base.iterate</code>. Also, because <code>JuliaFolds</code> is not Julia&#39;s default iterator implementation, and therefore sees less usage and development than Julia&#39;s built-in iterators, the package suffers from some compiler inference issues and obscure errors.</p> <div class=page-foot > <div class=copyright > Jakob Nybo Nissen. Last modified: July 27, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div>