<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/basic.css"> <link rel=icon  href="/assets/favicon.png"> <title>What&#39;s bad about Julia?</title> <header> <div class=blog-name ><a href="/">viralinstruction</a></div> <nav> <ul> <li><a href="/">Home</a> <li><a href="/about/">About</a> </ul> <img src="/assets/hamburger.svg" id=menu-icon > </nav> </header> <div class=franklin-content ><h1 id=whats_bad_about_julia ><a href="#whats_bad_about_julia" class=header-anchor >What&#39;s bad about Julia?</a></h1> <p><em>Written 2021-07-25, updated 2021-07-26</em></p> <p>Julia is my favorite programming language. More than that actually, perhaps I&#39;m a bit of a fanboy. Sometimes, though, the ceaseless celebration of Julia by fans like me can be a bit too much. It papers over legitimate problems in the language, hindering progress. And from an outsider perspective, it&#39;s not only insufferable &#40;I would guess&#41;, but also obfuscates the true pros and cons of the language. Learning why you may <em>not</em> want to choose to use a tool is just as important as learning why you may.</p> <p>This post is about all the major disadvantages of Julia. Some it will just be rants about things I particularly don&#39;t like - hopefuly they will be informative, too. A post like this is necessarily subjective. For example, some people believe Julia&#39;s lack of a Java-esque OOP is a design mistake. I don&#39;t, so the post won&#39;t go into that.</p> <h2 id=table_of_contents ><a href="#table_of_contents" class=header-anchor >Table of contents</a></h2> <div class=franklin-toc ><ol><li><a href="#table_of_contents">Table of contents</a><li><a href="#compile_time_latency">Compile time latency</a><li><a href="#large_memory_consumption">Large memory consumption</a><li><a href="#julia_cant_easily_integrate_into_other_languages">Julia can&#39;t easily integrate into other languages</a><li><a href="#weak_static_analysis">Weak static analysis</a><li><a href="#the_core_language_is_unstable">The core language is unstable</a><li><a href="#the_ecosystem_is_immature">The ecosystem is immature</a><li><a href="#the_type_system_works_poorly">The type system works poorly</a><ol><li><a href="#you_cant_extend_existing_types_with_data">You can&#39;t extend existing types with data</a><li><a href="#abstract_interfaces_are_unenforced_and_undiscoverable">Abstract interfaces are unenforced and undiscoverable</a><li><a href="#subtyping_is_an_all-or-nothing_thing">Subtyping is an all-or-nothing thing</a></ol><li><a href="#the_iterator_protocol_is_awful">The iterator protocol is awful</a><ol><li><a href="#the_protocol">The protocol</a><li><a href="#the_problem">The problem</a></ol><li><a href="#the_existing_iterators_are_poorly_implemented">The existing iterators are poorly implemented</a></ol></div> <h2 id=compile_time_latency ><a href="#compile_time_latency" class=header-anchor >Compile time latency</a></h2> <p>The very first thing you learn about Julia is that it&#39;s unresponsive. You open the REPL, type in something trivial like:</p> <pre><code class="julia hljs">julia&gt; sin(<span class=hljs-number >0.96</span>^<span class=hljs-number >5</span>)</code></pre>
<p>and see a <em>noticable</em> lag before the answer appears. As far as first impressions go, that isn&#39;t exactly great, especially for a language touted for its speed.</p>
<p>What&#39;s happening is that Julia is compiling <code>sin</code> - and also much of the code related to the REPL itself - first time you use it. This causes the lag we call <em>compile time latency</em>. Hence, the effect is even larger if we pull in new code from external packages: A small script that uses the packages <code>BioSequences</code> and <code>FASTX</code> may have a 2 second latency, even if the computation itself takes microseconds.</p>
<p>And it can get worse, still. Among Julians, latency is often referred to as TTFP: <em>Time To First Plot</em>. Graphical plotting became the posterboy for this problem because plotting involves a large amount of code that does relatively little work. Importing <code>Plots</code> and plotting the simplest line plot takes 8 seconds. However, being the posterboy for latency, Plots have gotten a lot of attention and engineering effort to reduce its latency, so it&#39;s hardly the worst package. Packages like <code>Turing</code> or <code>ApproxFun</code> may add half a minute to latency - <code>Turing</code> took 40 seconds to start up on my laptop. I&#39;ve heard of organizations whose codebase is in Julia where it takes 5 minutes to start a Julia process and load their packages.</p>
<p>So: How bad is this, really?</p>
<p>Well, it depends on what you use Julia for. Remember, the latency is a one-time cost every time you start a Julia process. If you&#39;re a data scientist who works for hours on end in a Jupyter notebook, ten or even 40 seconds of startup time is merely a small annoyance. I&#39;m in that category, broadly. When I start Julia, it rarely takes less than a few minutes before I shut down - and the Julia programs I run from command line takes minutes to complete, too. But some tasks and use cases rely on running lots of short Julia processes. These simply become impossible. For example, the latency makes Julia a complete non-starter for:</p>
<ul>
<li><p>Simple Unix commandline tools such as <code>cd</code>, <code>ripgrep</code> or <code>ls</code></p>

<li><p>Settings where responsiveness is key, say software in a self-driving car or airplane</p>

<li><p>Small composable scripts, e.g. as used in <a href="https://snakemake.readthedocs.io/en/stable/">Snakemake</a> workflows</p>

</ul>
<p>The latency also forces specific workflows for Julia users and developers. When using Python or Rust, you may be used to running some tests from command line, modifying a source file in the editor, then re-running the tests until they work. This workflow is not feasible in Julia - instead, you are essentially forced to into <em>REPL driven development</em>, where you have a single Julia session you keep open while modifying your code and observing the results.</p>
<p>Julias latency <em>is</em> improving, and there <em>are</em> hoops you can jump through to mitigate this problem somewhat. But the problem is fundamentally unsolvable, because it&#39;s built into Julia on a basic design level. So, before learning Julia, ask yourself if this is a dealbreaker for you.</p>
<h2 id=large_memory_consumption ><a href="#large_memory_consumption" class=header-anchor >Large memory consumption</a></h2>
<p>This one&#39;s pretty easy to demonstrate:</p>
<pre><code class="julia hljs">$ /usr/bin/time -f <span class=hljs-string >&quot;%M&quot;</span> julia hello_world.jl
Hello, world!
<span class=hljs-number >231316</span></code></pre>
<p>Yep, 231 MB memory consumption for a hello-world script. Julia&#39;s runtime is <em>enormous</em> - these megabytes are not just used by Julias compiler, it apparently pre-allocates BLAS buffers, just in case the user wants to multiply matrices in their hello-world script, you know. Forget the latency, a background consumption of 231 MB completely excludes usign Julia for anything but application-level programs running on a PC or a compute cluster. For anything else, be it mobile, embedded, daemon processes, etc, you&#39;ll need to use something else.</p>
<p>In fact, even for desktop-level applications, wasting 200&#43; MB on the Julia runtime is barely acceptable. Think of all the hate Electron gets for wasting resources. <em>Every</em> Julia program is as bad as Electron in this regard. A command-line calculator written in Julia consumes more resources than the video game Warcraft III.</p>
<h2 id=julia_cant_easily_integrate_into_other_languages ><a href="#julia_cant_easily_integrate_into_other_languages" class=header-anchor >Julia can&#39;t easily integrate into other languages</a></h2>
<p>Another consequence of Julia&#39;s massive runtime is that it makes it annoying to call into Julia from other languages. If your Python script needs to rely on Julia, you&#39;ll need to pay up front: Both the latency, <em>and</em> the 200-something megabytes.</p>
<p>Compare this to a static language like C, where you can compile a C lib to a binary that other programs simply calls into. Julians are usually very proud of the large amount of code sharing and code reuse in the Julia community, but it&#39;s worth noting that this sharing stops abruptly at the language barrier: We might be able to use a Rust library, but no-one would use a Julia library if they could avoid it. So if you want to code up some universally used library, you better go with a static language.</p>
<h2 id=weak_static_analysis ><a href="#weak_static_analysis" class=header-anchor >Weak static analysis</a></h2>
<p>This is one point where I&#39;ve changed perspective after having tried coding Rust. Before learning Rust, when I only knew Python and Julia I would have said something like:</p>
<blockquote>
<p>Sure, static typing is useful. But to ensure program correctness, you need tests anyway, and these tests will catch the vast majority of what would be compile-time errors. The small safety you lose in a dynamic language is more than made up by the time saved, which you can use to write better tests.</p>
</blockquote>
<p>How silly, past me, if only you knew&#33; See, I taught myself Rust by doing the <a href="https://github.com/jakobnissen/advent2020">Advent of Code 2020</a> in Rust. Being a neophyte, I was so bad at Rust that I had more than one compiler error per line of code on average. <em>Everything</em> was hard. And yet, for about two-thirds of the challenges, the <em>first</em> time the program compiled, it gave the correct answer.</p>
<p>That was astounding to me. Working with Python or Julia, I expected the program to crash. Programs always crash at first, right? Well, they do in Julia until you&#39;ve found the bugs by hitting them, and fixed them one by one. In fact, for me it was part of the development workflow, iteratatively write the solution, run it, watch where it crashes, fix it, repeat. The idea that you could just write the right program on the first try was wild. The experience was <em>not</em> that my program became more safe in the sense that I could ship it without sweat on my brow. No, it was that it <em>just worked</em>, and I could completely skip the entire debugging process that is core to the development experience of Julia, because I had gotten all the errors at compile time.</p>
<p>And this was for small scripts. I can only imagine the productivity boots that static analysis gives you for larger projects when you can safely refactor, because you know immediately if you do something wrong.</p>
<p>Back to Julia: It lies somewhere in between Python and Rust in terms of static analysis and safety. You <em>can</em> add type annotations to your functions, but the errors still only appear at runtime, and it&#39;s generally considered un-idiomatic to use too many type annotations. <a href="https://github.com/julia-vscode/StaticLint.jl">Linting</a> and <a href="https://github.com/aviatesk/JET.jl">static analysis</a> for Julia are slowly appearing and improving, but compared to Rust they catch just a small fraction of errors. When writing generic package code where types are mostly indeterminate until runtime, they are close to useless.</p>
<p>Another issue with static analysis in Julia is that, because writing un-inferrable code is a completely valid &#40;if ineffient&#41; coding style, there is a lot of code that simply can&#39;t be statically analysed. Similarly, you can have a Julia package whose dynamic style causes tonnes of &quot;issues&quot; according to the static analyzer, which nonetheless work fine. If your package depends on such a package, your static analysis will be flooded with false positives originating from the third-party code.</p>
<p>I&#39;m a big fan of these tools, but honestly, in their current state, you can rely on the linter to catch typos or wrong type signatures, and on the static analyzer to analyze specific function calls you ask it to... but that&#39;s about it.</p>
<p>Is it unfair to criticise a <em>dynamic</em> language for not having <em>static</em> analysis? Isn&#39;t that implicit? Perhaps. But this post is about the weaknesses of Julia, and no matter how you justify it, poor static analysis is most definitely a weakness.</p>
<h2 id=the_core_language_is_unstable ><a href="#the_core_language_is_unstable" class=header-anchor >The core language is unstable</a></h2>
<p>Julia released 1.0 in 2018, and has been committed to no breakage since then. So how can I say the language is unstable?</p>
<p>Instability isn&#39;t just about breaking changes. It&#39;s also about bugs and incorrect documentation. And here, Julia is pretty bad. Having used Julia since just before 1.0, I run into bugs in the core language regularly. Not often, but perhaps once every couple of months. I can&#39;t recall ever having run into a bug in Python.</p>
<p>If you doubt it, take a look at the <a href="https://github.com/JuliaLang/julia/issues?page&#61;2&amp;q&#61;is&#37;3Aissue&#43;is&#37;3Aopen&#43;label&#37;3Abug">open issues marked as bugs</a>. Some of these are transient bugs on master, but there are <em>many</em>, <em>many</em> old bugs you can still go in and trigger from the REPL on the stable Julia release. Here&#39;s one <a href="https://github.com/JuliaLang/julia/issues/36605">I reported about a year ago</a>, and which still hasn&#39;t been fixed:</p>
<pre><code class="julia hljs">julia&gt; open(read, <span class=hljs-string >&quot;/home/jakob/Documents&quot;</span>) <span class=hljs-comment ># yes, a directory</span>
<span class=hljs-built_in >UInt8</span>[]</code></pre>
<p>I don&#39;t think it&#39;s because the Julia devs are careless, or Julia isn&#39;t well tested. It&#39;s just a matter of bugs continuously being discovered because Julia is relatively young software. As it matures and stabilizes post 1.0, the number of bugs have gone down and will continue to do so in the future. But until it does, don&#39;t expect mature, stable software when using Julia.</p>
<p>There is, however, also the issue of unstable performance, where Julia is a uniquely awkward situation. Other dynamic languages are slow, and people using them write code expecting them to be slow. Static languages are fast, because the compiler has full type information during the compilation process. If the compiler can&#39;t infer the type of something, the program won&#39;t compile. Most notably, because an inference failure in static languages causes the compilation to fail, <em>the compiler&#39;s inference is part of the API, and must remain stable</em>. Not so in Julia.</p>
<p>In Julia, what the compiler knows about your code and the optimizations it does is a pure implementation detail - at long as it produces the correct result. Even in situations where <em>nothing</em> can be inferred about the types Julia will run and produce the correct result, just hundreds of times slower. That means that a compiler change that causes a failure of inference and a 100x performance regression is not a breaking change. So, these happens.</p>
<p>I mean, don&#39;t get me wrong, they don&#39;t happen <em>often</em>, and they usually only affect part of your program, so the regression is rarely that dramatic. The Julia team really tries to avoid regressions like that, and they&#39;re usually picked up and fixed on the master branch of Julia before they make it to any release. Still, if you&#39;ve maintained a few Julia packages, I bet it has happened to you more than once.</p>
<h2 id=the_ecosystem_is_immature ><a href="#the_ecosystem_is_immature" class=header-anchor >The ecosystem is immature</a></h2>
<p>A more important consequence of Julia being a young, immature language is that the package ecosystem is similarly immature. Compared to the core language, which have a huge number of users, and more developers, the ecosystem settles more slowly. This has several consequences for Julia:</p>
<p>First, compared to established languages, lots of packages are missing. Especially if you work in a niche subject, as most scientists do, you are much more likely to find a Python or R package to fit your needs than a Julia package. This situation will obviously improve over time, but right now, Julia is still quite far behind.</p>
<p>You&#39;re also much more likely to find outdated or unmaintained packages in Julia. This is not because Julia packages tend to fall into disrepair more quickly than other languages, I think, but rather because packages which has already existed for 20 years are more likely to last another five more years than packages that have existed for two years. It&#39;s only been three years since Julia 1.0 came out, so if you find a blog post from 2015, any posted Julia code is unlike to work, and the packages have probably released several breaking changes since then. In comparison, the Python package Numpy has been around five times longer than Julia 1.0&#33;</p>
<p>In software ecosystems, it also takes a while for effort to consolidate to well-known packages. In Python, everybody knows, for example, to use <code>pandas</code> when working with dataframes. It has become the de-facto standard. And if it is to be dethroned, any contender must compare favorably against <code>pandas</code>, which means it must itself be a solid, well-used package.</p>
<p>Perhaps most critically, the developer tooling sorrounding Julia is also immature, with lots of basic functionality missing. This is also a consequence of the ecosystem simply not being mature enough, with too little development effort behind it &#40;notably, no large companies have made large contributions to Julia, unlike every other language I know of&#41;. Here are a few examples, haphazardly chosen:</p>
<ul>
<li><p>Julia&#39;s built-in <code>Test</code> package is barebones, and does not offer setup and teardown of tests, nor the functionality to only run a subset of the full test suite.</p>

<li><p>The editor experience is not great with Julia. It&#39;s getting better, but with the foremost Julia IDE developed by a few people in their spare time, it has all the crashes, slowness and instability you would expect.</p>

<li><p>Static analysis is brand new, and feels like it hasn&#39;t yet settled into its final form. It also has no IDE integration.</p>

<li><p>There is no common framework for benchmarking and profiling Julia code. In a single session, you may analyze the same function with <code>BenchmarkTools</code>, <code>Profile</code>, <code>JET</code>, <code>JETTest</code>, <code>@code_native</code> and <code>Cthulhu</code>, which each has to be loaded and launched individually. This is a huge time sink, and a terrible user experience. It should be possible to gather several of these tools in a single analysis package, but it has not yet been done.</p>

</ul>
<h2 id=the_type_system_works_poorly ><a href="#the_type_system_works_poorly" class=header-anchor >The type system works poorly</a></h2>
<p>This is the most controversial of my gripes with Julia. People who don&#39;t know Julia have no idea what I mean when I say the subtyping system is bad, and people who <em>do</em> know Julia are unlikely to agree with me. I&#39;ll give a brief recap of how the system works for anyone not familiar:</p>
<p>In Julia, types can be either <em>abstract</em> or <em>concrete</em>. Abstract types are considered &quot;incomplete&quot;. They can have subtypes, but they cannot hold any data fields or be instantiated - they are incomplete, after all. Concrete types can be instantiated and may have data, but cannot be subtyped since they are final. Here is an imaginary example:</p>
<pre><code class="julia hljs"><span class=hljs-comment ># Abstract type subtyping BioSequence (itself abstract)</span>
<span class=hljs-keyword >abstract type</span> NucleotideSequence &lt;: BioSequence <span class=hljs-keyword >end</span>

<span class=hljs-comment ># Concrete types with fields subtyping NucleotideSequence</span>
<span class=hljs-comment ># cannot be subtyped!</span>
<span class=hljs-keyword >struct</span> DNASequence &lt;: NucleotideSequence
    x::<span class=hljs-built_in >Vector</span>{DNA}
<span class=hljs-keyword >end</span></code></pre>
<p>You can define methods for abstract types, which are inherited by all its subtypes &#40;that is, <em>behaviour</em> can be inherited, but not <em>data</em>&#41;. But if a concrete type define the same method, that will overwrite the abstract one:</p>
<pre><code class="julia hljs"><span class=hljs-comment ># Generic function, is slow</span>
<span class=hljs-keyword >function</span> print(io::<span class=hljs-built_in >IO</span>, seq::NucleotideSequence)
    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> seq
        print(io, i)
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span>

<span class=hljs-comment ># Specialized function, overwrites generic</span>
<span class=hljs-keyword >function</span> print(io::<span class=hljs-built_in >IO</span>, seq::DNASequence)
    write(io, seq.x) <span class=hljs-comment ># optimized write implementation</span>
<span class=hljs-keyword >end</span></code></pre>
<p>So you can create type heiarchies, implement generic fallback methods, and overwrite them whenever you want. Neat&#33; What&#39;s not to like? Well...</p>
<h3 id=you_cant_extend_existing_types_with_data ><a href="#you_cant_extend_existing_types_with_data" class=header-anchor >You can&#39;t extend existing types with data</a></h3>
<p>Say you implement some useful <code>MyType</code>. Another package thinks it&#39;s really neat and wants to extend the type. Too bad, that&#39;s just not possible - <code>MyType</code> is final and can&#39;t be extended. If the original author didn&#39;t add an abstract supertype for <code>MyType</code> you&#39;re out of luck. And in all probability, the author didn&#39;t. After all, good coders usually follow the <a href="https://en.wikipedia.org/wiki/You_aren&#37;27t_gonna_need_it">YAGNI</a> principle: Don&#39;t pre-emptively implement what you don&#39;t need.</p>
<p>In e.g. Python, this is just not a problem. You can subclass whatever you damn well please. In Rust, the problem is not even recognizable: Any type you write can freely derive traits and is not at all constrained by where it is placed in the type hierarchy, because there <em>is</em> no type hierarchy.</p>
<h3 id=abstract_interfaces_are_unenforced_and_undiscoverable ><a href="#abstract_interfaces_are_unenforced_and_undiscoverable" class=header-anchor >Abstract interfaces are unenforced and undiscoverable</a></h3>
<p>Suppose, on the other hand, you find out the author <em>did</em> actually add <code>AbstractMyType</code>. Then you can subtype it:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >struct</span> YourType &lt;: AbstractMyType
    [ stuff ]
<span class=hljs-keyword >end</span></code></pre>
<p>... and now what? What do you need to implement? What does the abstract type require? What does it guarantee? Julia offers absolutely no way of finding out what the abstract interface is, or how you conform to it. In fact, even in Base Julia, fundamental types like <code>AbstractSet</code>, <code>AbstractChannel</code>, <code>Number</code> and <code>AbstractFloat</code> are just not documented. What actually <em>is</em> a <code>Number</code>, in Julia? I mean, we know what a number is conceptually, but what are you opting in to when you subtype <code>Number</code>? What do you promise? Who knows? Do even the core developers know? I doubt it.</p>
<p>A few abstract types in Julia <em>are</em> well documented, most notably <code>AbstractArray</code> and its abstract subtypes, and it&#39;s probably no coindidence that Julia&#39;s array ecosystem is so good. But this is a singular good example, not the general pattern. Ironically, this exception is often held up as an example of why the Julia type system <em>works well</em>.</p>
<p>Here is a fun challenge for anyone who thinks &quot;it can&#39;t be that bad&quot;: Try to implement a <code>TwoWayDict</code>, an <code>AbstractDict</code> where if <code>d&#91;a&#93; &#61; b</code>, then <code>d&#91;b&#93; &#61; a</code>. In Python, which has inheritance, this is trivial. You simply subclass <code>dict</code>, overwrite a handful of its methods, and everything else works. In Julia, you have to define its data layout first - quite a drag, since dictionaries have a complicated structure &#40;remember, you can&#39;t inherit data&#33;&#41;. Then you must figure out everything <code>AbstractDict</code> promises &#40;good luck&#33;&#41; and implement that.</p>
<h3 id=subtyping_is_an_all-or-nothing_thing ><a href="#subtyping_is_an_all-or-nothing_thing" class=header-anchor >Subtyping is an all-or-nothing thing</a></h3>
<p>Another problem with relying on subtyping for behaviour is that each type can only have one supertype, and it inherits <em>all</em> of its methods. Often, that turns out to not be what you want: New types often has properties of several interfaces: Perhaps they are set-like, iterable, callable, printable, etc. But no, says Julia, pick <em>one</em> thing. To be fair, &quot;iterable&quot;, &quot;callable&quot; and &quot;printable&quot; are so generic and broadly useful they are not implemented using subtyping in Julia - but doesn&#39;t that say something?</p>
<p>In Rust, these properties are implemented through traits instead. Because each trait is defined independently, each type faces a smorgasbord of possibilities. It can choose <em>exactly</em> what it can support, and nothing more. It also leads to more code reuse, as you can e.g. simply derive <code>Copy</code> and get it without having to implement it. It also means there is an incentive to create &quot;smaller&quot; traits. In Julia, if you subtype <code>AbstractFoo</code>, you opt in to a potentially huge number of methods. In contrast, it&#39;s no problem to create very specific traits that concerns only a few - or one - method.</p>
<p>Julia <em>does</em> have traits, but they&#39;re half-baked, not supported on a language level, and haphazardly used. They are usually implemented through multiple dispatch, which is also annoying since it can make it difficult to understand what is actually being called. Julia&#39;s broadcasting mechanism, for example, is controlled primarily through traits, and just finding the method ultimately being called is a pain.</p>
<p>Also, since so much of Julia&#39;s behaviour is controlled through the type of variables instead of traits, people are tempted to use wrapper types if they want type <code>A</code> to be able to behave like type <code>B</code>. But those are <a href="https://github.com/JuliaLang/julia/issues/37790">a terrible idea</a>, since it only moves the problem and in fact makes it worse: You now have a new wrapper type you need to implement everything for, and even if you do, the wrapper type is now of type <code>B</code>, and doesn&#39;t have access to the methods of <code>A</code>&#33;</p>
<p>A good example of the subtyping system not working is Julia&#39;s standard library <code>LinearAlgebra</code>. This package uses both wrapper types and traits to try to overcome the limitations of the type system, and suffers from both the workarounds. But an even clearer example of the failure of the type system is its use of <em>big unions</em>, that is, functions whose type signature has arguments of the type &quot;A or B or C or D or E or ...&quot;. And these unions of types gets out of control: If you have Julia at hand, try to type in <code>LinearAlgebra.StridedVecOrMat</code> and watch the horror. The use of such an abomination is a symptom of an unsolved underlying problem with the type system.</p>
<h2 id=the_iterator_protocol_is_awful ><a href="#the_iterator_protocol_is_awful" class=header-anchor >The iterator protocol is awful</a></h2>
<h3 id=the_protocol ><a href="#the_protocol" class=header-anchor >The protocol</a></h3>
<p>By &quot;the iterator protocol&quot;, I mean: How does a for loop work? The three languages I&#39;m familiar with, Python, Rust and Julia, all handle this slightly different. In Julia, the following code:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> x
    <span class=hljs-comment ># stuff</span>
<span class=hljs-keyword >end</span></code></pre>
<p>lowers into:</p>
<pre><code class="julia hljs">itval = iterate(x)
<span class=hljs-keyword >while</span> itval !== <span class=hljs-literal >nothing</span>
    i, state = itval
    <span class=hljs-comment ># stuff</span>
    itval = iterate(x, state)
<span class=hljs-keyword >end</span></code></pre>
<p>This means that, to implement an iterator, you need to implement <code>iterate&#40;x&#41;</code> and <code>iterate&#40;x, state&#41;</code>. It should return <code>nothing</code> when the iteration is done, and <code>&#40;i, next_state&#41;</code> when it still has elements. By the way, you <em>also</em> need to implement a few traits, which Julia does not warn you about if you forget to, or implement them wrongly. But <a href="#abstract_interfaces_are_unenforced_and_undiscoverable">I gripe about that elsewhere</a>.</p>
<p>So: Why is it like that? One of the reason it was designed like that is that it makes the <code>iterate</code> function and the iterator itself <em>stateless</em>, since the state is stored in the local variable passed as an argument to the <code>iterate</code> function. It means you can&#39;t have bugs like this Python bug:</p>
<pre><code class="python hljs"><span class=hljs-meta >&gt;&gt;&gt; </span><span class=hljs-built_in >iter</span> = (i+<span class=hljs-number >1</span> <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-number >3</span>))
<span class=hljs-meta >&gt;&gt;&gt; </span>length = <span class=hljs-built_in >sum</span>(<span class=hljs-number >1</span> <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-built_in >iter</span>)
<span class=hljs-meta >&gt;&gt;&gt; </span><span class=hljs-built_in >list</span>(<span class=hljs-built_in >iter</span>) <span class=hljs-comment ># oops!</span>
[]</code></pre>
<h3 id=the_problem ><a href="#the_problem" class=header-anchor >The problem</a></h3>
<p>First, you <em>absolutely</em> can have the same bug as in Python, because <em>some</em> iterators <em>are</em> stateful&#33; For example, if you read a file:</p>
<pre><code class="julia hljs">julia&gt; lines = eachline(<span class=hljs-string >&quot;my_file.txt&quot;</span>);

julia&gt; n_lines = count(x -&gt; <span class=hljs-literal >true</span>, lines);

julia&gt; collect(lines)
<span class=hljs-built_in >String</span>[]</code></pre>
<p>And since there is no way of knowing programatically &#40;and certainly not statically&#41; if an iterator is stateful, you better adopt a coding style that assumes all iterators are stateful, anyway.</p>
<p>But that&#39;s not the <em>real</em> problem. The real problem is that Julia&#39;s iterators are not stateless in the sense that really matters. The state is still there as a variable, and <em>needs to be kept track of by the programmer</em>. So it&#39;s &quot;stateless&quot; in the worst possible way: In the sense that the compiler and the language doesn&#39;t know about it and offloads the problem to the programmer. Reasoning about state across time is a famously hard problem in programming, and with Julia&#39;s iterators, you get to feel 100&#37; of that pain.</p>
<p>For example, suppose you create an iterator that you need to process in two stages: First, you do some initialization with the first elements of the iterator. Perhaps it&#39;s an iterator of lines and you need to skip the header. After that, you iterate over the remaining arguments. You implement this as the functions <code>parse_header</code> and <code>parse_rest</code> In Julia, <em>you need to explicitly pass state between the functions</em> - not to mention all the boilerplate code it introduces because you now can&#39;t iterate over the iterator in a for loop since that would &quot;restart&quot; the iterator. Well, <em>maybe</em> it would, who knows if it&#39;s stateless&#33;</p>
<p>If you&#39;re a Julian reading this with scepticism, try implementing an interleaving iterator: It should take any number of iterators <code>x1, x2, ... xn</code> and produce a stream of their interleaved values: <code>x1_1, x2_x1, ... nx_1, x1_2 ... xn_m</code>. Easy peasy in Python, a nightmare in Julia because you have to juggle N states manually in the function. Or try re-implementing <code>zip</code> or a roundrobin iterator.</p>
<h2 id=the_existing_iterators_are_poorly_implemented ><a href="#the_existing_iterators_are_poorly_implemented" class=header-anchor >The existing iterators are poorly implemented</a></h2>
<p>I didn&#39;t really notice this until I tried Rust, and Julias <code>Transducers</code> package, both of whom implements iterators way betters than Julia itself does. This gripe is not <em>one single</em> thing, but rather a series of smaller gripes about how Julia&#39;s iterators are just... generally not that well designed.</p>
<ol>
<li><p><code>eachline&#40;::String&#41;</code> and <code>countlines&#40;::String&#41;</code> does <em>not</em> iterate over lines, or count lines of strings. Instead, they interpret the strings as filenames, tries to open the file and iterate over the lines in it. <em>What?</em> So, how do you operate on strings? You have to wrap the strings in <code>IO</code> objects first. Yeah. that&#39;s another gripe, there is no such type as a <code>Path</code> in Julia - it just uses strings. Why not? I honestly don&#39;t know, other than perhaps the Julia devs wanted to get 1.0 out and didn&#39;t have time to implement them.</p>

<li><p><code>map</code>, <code>filter</code> and <code>split</code> are eager, returning <code>Array</code>. There is <em>literally</em> no reason for this - it only makes the code slower and less generic. I can&#39;t think of a single upside - perhaps other than that it saves you typing <code>collect</code> once in a while. Newer versions of Julia introduced <code>Iterators.map</code> and <code>Iterators.filter</code> which <em>are</em> lazy, but using them means breaking backwards compatibility, and also, you have to use the ugly identifier <code>Iterators</code>. And for <code>split</code>, there is no such escape hatch - you just have to accept it&#39;s slow and unnecessarily allocating.</p>

<li><p>Functional programming functions like <code>map</code> and <code>filter</code> can&#39;t take functions. That is, I cannot call <code>map&#40;f&#41;</code> and get a &quot;mapper&quot; function. I usually &quot;solve&quot; this by defining <code>imap&#40;f&#41; &#61; x -&gt; Iterators.map&#40;f, x&#41;</code> in the beginning of my files, but honestly, Julia&#39;s iterators should work like this by default.</p>

</ol>
<p>But Jakob, you say, don&#39;t you know about Takafumi Arakaki&#39;s amazing <code>JuliaFolds</code> ecosystem which reimagines Julia&#39;s iterator protocol and functional programming and gives you everything you ask for? Yes I do, and it&#39;s the best thing since sliced bread, BUT this basic functionality simply <em>can&#39;t</em> be a package. It <em>needs</em> to be in Base Julia. For example, if I use Arakaki&#39;s packages to create an &quot;iterator&quot;, I can&#39;t iterate over it with a normal Julia for loop, because the for loop is built into Julia&#39;s language to expect the <code>iterator</code> protocol. Also, because <code>JuliaFolds</code> is is not Julia&#39;s default and therefore sees less usage and development than Julia&#39;s iterators, the package suffers from some compiler inference issues and obscure errors.</p>
<div class=page-foot >
  <div class=copyright >
    Jakob Nybo Nissen. Last modified: July 26, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>