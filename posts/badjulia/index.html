<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/basic.css"> <link rel=icon  href="/assets/v.svg"> <title>What&#39;s bad about Julia?</title> <header> <div class=blog-name ><a href="/">viralinstruction</a></div> <nav> <ul> <li><a href="/">Home</a> <li><a href="/about/">About</a> <li><a href="/feed.xml">RSS</a> </ul> <img src="/assets/hamburger.svg" id=menu-icon > </nav> </header> <div class=franklin-content ><h1 id=whats_bad_about_julia ><a href="#whats_bad_about_julia" class=header-anchor >What&#39;s bad about Julia?</a></h1> <p><em>Written 2021-07-25, updated 2021-11-27</em></p> <p>Julia is my favorite programming language. More than that actually, perhaps I&#39;m a bit of a fanboy. Sometimes, though, the ceaseless celebration of Julia by fans like me can be a bit too much. It papers over legitimate problems in the language, hindering progress. And from an outsider perspective, it&#39;s not only insufferable &#40;I would guess&#41;, but also obfuscates the true pros and cons of the language. <a href="https://matklad.github.io/2020/09/20/why-not-rust.html">Learning why you may <em>not</em> want to choose to use a tool</a> is just as important as learning why you may.</p> <p>This post is about all the major disadvantages of Julia. Some of it will just be rants about things I particularly don&#39;t like - hopefully they will be informative, too. A post like this is necessarily subjective. For example, some people believe Julia&#39;s lack of a Java-esque OOP is a design mistake. I don&#39;t, so the post won&#39;t go into that.</p> <div class=toc-header >Table of contents</div> <div class=franklin-toc ><ol><li><a href="#compile_time_latency">Compile time latency</a><li><a href="#large_memory_consumption">Large memory consumption</a><li><a href="#julia_cant_easily_integrate_into_other_languages">Julia can&#39;t easily integrate into other languages</a><li><a href="#weak_static_analysis">Weak static analysis</a><li><a href="#the_core_language_is_unstable">The core language is unstable</a><li><a href="#the_ecosystem_is_immature">The ecosystem is immature</a><li><a href="#the_type_system_works_poorly">The type system works poorly</a><ol><li><a href="#you_cant_extend_existing_types_with_data">You can&#39;t extend existing types with data</a><li><a href="#abstract_interfaces_are_unenforced_and_undiscoverable">Abstract interfaces are unenforced and undiscoverable</a><li><a href="#subtyping_is_an_all-or-nothing_thing">Subtyping is an all-or-nothing thing</a></ol><li><a href="#the_iterator_protocol_is_weird_and_too_hard_to_use">The iterator protocol is weird and too hard to use</a><ol><li><a href="#the_protocol">The protocol</a><li><a href="#the_problem">The problem</a></ol><li><a href="#functional_programming_primitives_are_not_well_designed">Functional programming primitives are not well designed</a><li><a href="#misc_gripes">Misc gripes</a><ol><li><a href="#there_is_no_path_type">There is no Path type...</a><li><a href="#and_no_option_type">..and no Option type</a></ol></ol></div> <h2 id=compile_time_latency ><a href="#compile_time_latency" class=header-anchor >Compile time latency</a></h2> <p>The very first thing you learn about Julia is that it&#39;s unresponsive. You open your favorite IDE, launch a Julia REPL, start typing... and see a <em>noticable</em> lag before any text appears. As far as first impressions go, that isn&#39;t exactly great, especially for a language touted for its speed.</p> <p>What&#39;s happening is that Julia is compiling the code needed for its REPL and its integration with your editor. This &quot;runtime&quot; compilation causes the lag we call <em>compile time latency</em>. Hence, the effect is even larger if we pull in new code from external packages: A small script that uses the packages <code>BioSequences</code> and <code>FASTX</code> may have a 2 second latency, even if the computation itself takes microseconds.</p> <p>And it can get worse, still. Among Julians, latency is often referred to as TTFP: <em>Time To First Plot</em>. Graphical plotting became the posterboy for this problem because plotting involves a large amount of code that does relatively little work. Importing <code>Plots</code> and plotting the simplest line plot takes 8 seconds. However, being the posterboy for latency, Plots have gotten a lot of attention and engineering effort to reduce its latency, so it&#39;s hardly the worst package. Packages like <code>Turing</code> or <code>ApproxFun</code> may add half a minute to latency - <code>Turing</code> took 40 seconds to start up on my laptop. I&#39;ve heard of organizations whose codebase is in Julia where it takes 5 minutes to start a Julia process and load their packages.</p> <p>So: How bad is this, really?</p> <p>Well, it depends on what you use Julia for. Remember, the latency is a one-time cost every time you start a Julia process. If you&#39;re a data scientist who works for hours on end in a Jupyter notebook, ten or even 40 seconds of startup time is merely a small annoyance. I&#39;m in that category, broadly. When I start Julia, it rarely takes less than a few minutes before I shut down - and the Julia programs I run from command line takes minutes to complete, too. But some tasks and use cases rely on running lots of short Julia processes. These simply become impossible. For example, the latency makes Julia a complete non-starter for:</p> <ul> <li><p>Simple Unix commandline tools such as <code>ripgrep</code> or <code>ls</code></p> <li><p>Settings where responsiveness is key, say software in a self-driving car or airplane</p> <li><p>Small composable scripts, e.g. as used in <a href="https://snakemake.readthedocs.io/en/stable/">Snakemake</a> workflows</p> </ul> <p>The latency also forces specific workflows for Julia users and developers. When using Python or Rust, you may be used to running some tests from command line, modifying a source file in the editor, then re-running the tests from command line until they work. This workflow is not feasible in Julia, because latency would occur every time you invoked Julia from command line. Instead, you are essentially forced to into <em>REPL driven development</em>, where you have a single Julia session you keep open alongside your editor, and interact with Julia &#40;e.g. running tests or code analysis&#41; only thorugh that REPL.</p> <p>Julias latency <em>is</em> improving, and there <em>are</em> hoops you can jump through to mitigate this problem somewhat. But the problem is fundamentally unsolvable, because it&#39;s built into Julia on a basic design level. So, before learning Julia, ask yourself if this is a dealbreaker for you.</p> <h2 id=large_memory_consumption ><a href="#large_memory_consumption" class=header-anchor >Large memory consumption</a></h2> <p>This one&#39;s pretty easy to demonstrate:</p> <div class=shellcode ><pre><code class=language-plaintext >&#36; /usr/bin/time -f &quot;&#37;M&quot; julia hello_world.jl
Hello, world&#33;
148724</code></pre></div> <p>Yep, ~150 MB memory consumption for a hello-world script. Julia&#39;s runtime is <em>enormous</em> - these megabytes are not just used by Julias compiler, it apparently pre-allocates BLAS buffers, just in case the user wants to multiply matrices in their hello-world script, you know. Forget the latency, a background consumption of 150 MB completely excludes using Julia for anything but application-level programs running on a PC or a compute cluster. For anything else, be it mobile, embedded, daemon processes, etc, you&#39;ll need to use something else.</p> <p>In fact, even for desktop-level applications, consuming 150 MB on the Julia runtime is pushing it. Think of all the hate Electron gets for wasting resources. <em>Every</em> Julia program is in the same ballpark as Electron in this regard. A command-line calculator written in Julia consumes more memory than the 2003 video game <em>Command &amp; Conquer: Generals</em>.</p> <h2 id=julia_cant_easily_integrate_into_other_languages ><a href="#julia_cant_easily_integrate_into_other_languages" class=header-anchor >Julia can&#39;t easily integrate into other languages</a></h2> <p>Another consequence of Julia&#39;s massive runtime is that it makes it annoying to call into Julia from other languages. If your Python script needs to rely on Julia, you&#39;ll need to pay up front: Both the latency, <em>and</em> the 150-ish megabytes.</p> <p>Compare this to a static language like C, where you can compile a C lib to a binary that other programs simply calls into. Julians are usually very proud of <a href="https://www.youtube.com/watch?v&#61;kc9HwsxE1OY">the large amount of code sharing and code reuse</a> in the Julia community, but it&#39;s worth noting that this sharing stops abruptly at the language barrier: We might be able to use a Rust library in Julia with little friction, but no-one would use a Julia library if they could avoid it. So if you want to code up some universally used library, you better go with a static language.</p> <h2 id=weak_static_analysis ><a href="#weak_static_analysis" class=header-anchor >Weak static analysis</a></h2> <p>This is one point where I&#39;ve changed perspective after having tried coding Rust. Before learning Rust, when I only knew Python and Julia I would have said something like:</p> <blockquote> <p>Sure, static analysis is useful. But to ensure program correctness, you need tests anyway, and these tests will catch the vast majority of what would be compile-time errors. The small safety you lose in a dynamic language is more than made up by the time saved, which you can use to write better tests.</p> </blockquote> <p>How silly, past me, if only you knew&#33; See, I taught myself Rust by doing the <a href="https://github.com/jakobnissen/advent2020">Advent of Code 2020</a> in Rust. Being a neophyte, I was so bad at Rust that I had more than one compiler error per line of code on average. <em>Everything</em> was hard. And yet, for about two-thirds of the challenges, the <em>first</em> time the program compiled, it gave the correct answer.</p> <p>That was astounding to me. Working with Python or Julia, I expected the program to crash. Programs always crash at first, right? Well, they do in Julia until you&#39;ve found the bugs by hitting them, and fixed them one by one. In fact, for me it was part of the development workflow, iteratively write the solution, run it, watch where it crashes, fix it, repeat. The idea that you could just write the right program on the first try was wild. The experience was <em>not</em> that my program became more safe in the sense that I could ship it without sweat on my brow. No, it was that it <em>just worked</em>, and I could completely skip the entire debugging process that is core to the development experience of Julia, because I had gotten all the errors at compile time.</p> <p>And this was for small scripts. I can only imagine the productivity boosts that static analysis gives you for larger projects when you can safely refactor, because you know immediately if you do something wrong.</p> <p>Back to Julia: It lies somewhere in between Python and Rust in terms of static analysis and safety. You <em>can</em> add type annotations to your functions, but the errors still only appear at runtime, and it&#39;s generally considered un-idiomatic to use too many type annotations, <a href="#the_type_system_works_poorly">with good reason</a>. <a href="https://github.com/julia-vscode/StaticLint.jl">Linting</a> and <a href="https://github.com/aviatesk/JET.jl">static analysis</a> for Julia are slowly appearing and improving, but compared to Rust they catch just a small fraction of errors. When writing generic package code where types are mostly indeterminate until runtime, they can&#39;t do much type analysis.</p> <p>Another issue with static analysis in Julia is that, because writing un-inferrable code is a completely valid &#40;if inefficient&#41; coding style, there is a lot of code that simply can&#39;t be statically analysed. Similarly, you can have a Julia package whose dynamic style causes tonnes of &quot;issues&quot; according to the static analyzer, which nonetheless work fine. If your package depends on such a package, your static analysis will be flooded with false positives originating from the third-party code.</p> <p>I&#39;m a big fan of these tools, but honestly, in their current state, you can rely on the linter to catch typos or wrong type signatures, and on the static analyzer to analyze specific function calls you ask it to... but that&#39;s about it.</p> <p>Is it unfair to criticise a <em>dynamic</em> language for not having <em>static</em> analysis? Isn&#39;t that implicit? Perhaps. But this post is about the weaknesses of Julia, and no matter how you justify it, poor static analysis is most definitely a weakness.</p> <h2 id=the_core_language_is_unstable ><a href="#the_core_language_is_unstable" class=header-anchor >The core language is unstable</a></h2> <p>Julia released 1.0 in 2018, and has been committed to no breakage since then. So how can I say the language is unstable?</p> <p>Instability isn&#39;t just about breaking changes. It&#39;s also about bugs and incorrect documentation. And here, Julia is pretty bad. Having used Julia since just before 1.0, I run into bugs in the core language regularly. Not often, but perhaps once every couple of months. I can&#39;t recall ever having run into a bug in Python.</p> <p>If you doubt it, take a look at the <a href="https://github.com/JuliaLang/julia/issues?q&#61;is&#37;3Aissue&#43;is&#37;3Aopen&#43;label&#37;3Abug">open issues marked as bugs</a>. Some of these are transient bugs on master, but there are <em>many</em>, <em>many</em> old bugs you can still go in and trigger from the REPL on the stable Julia release. Here&#39;s one <a href="https://github.com/JuliaLang/julia/issues/36605">I reported about a year ago</a>, and which still hasn&#39;t been fixed:</p> <div class=juliacode ><pre><code class=language-julia >julia&gt; open&#40;read, &quot;/home/jakob/Documents&quot;&#41; # yes, a directory
UInt8&#91;&#93;</code></pre></div> <p>Perhaps you think that reading directories as files is not really a bug, even in a high-level language. In that case, you can try collecting stateful generators:</p> <div class=juliacode ><pre><code class=language-julia >julia&gt; collect&#40;&#40;i for i in Iterators.Stateful&#40;1:3&#41;&#41;&#41;
2-element Vector&#123;Int64&#125;:
 1
 2</code></pre></div> <p>Where Julia will silently give the objectively wrong answer. That one has been known for more than one-and-a-half years, and an issue been filed &#40;and looked at&#41; more than a year ago.</p> <p>The instability goes beyond the core language itself. Most of the times I have made PR to the Julia GitHub repository the past year or so, CI has failed for spurious reasons. In fact, when scrolling through the list of recently merged PRs, every single one of them failed CI and was merged anyway, presumably due to unstable CI. I know the Julia devops people are working hard on this, but it is worrying that Julia doesn&#39;t pass its own tests.</p> <p>A similar story can be told about Julia&#39;s package servers. Most experienced Julians know to set <code>JULIA_PKG_SERVER&#61;&quot;&quot;</code> if the package server gets slow. This was not documented until recently - the reason we know how to set it is because the package server so often causes trouble. For example, the Eastern US package server have had &quot;major outage&quot; for about 70 of the last 90 days. It&#39;s still up and running, it just serves Julia users out-of-date packages.</p> <p>I don&#39;t think it&#39;s because the Julia devs are careless. It&#39;s just a matter of bugs continuously being discovered because Julia is relatively young software, and because it&#39;s a big language with lots of surface for bugs. Perhaps it also comes from a culture where features come first, and tests for correctness come second. As Julia matures and stabilizes post 1.0, the number of bugs have gone down and will continue to do so in the future. But until it does, don&#39;t expect mature, stable software when using Julia.</p> <p>There is, however, also the issue of unstable performance, where Julia is a uniquely awkward situation. Other dynamic languages are slow, and people using them write code expecting them to be slow. Static languages are fast, because the compiler has full type information during the compilation process. If the compiler can&#39;t infer the type of something, the program won&#39;t compile. Importantly, because an inference failure in static languages causes the compilation to fail, <em>the compiler&#39;s inference is part of the API, and must remain stable</em>. Not so in Julia.</p> <p>In Julia, what the compiler knows about your code and the optimizations it does is a pure implementation detail - at long as it produces the correct result. Even in situations where <em>nothing</em> can be inferred about the types Julia will run and produce the correct result, just hundreds of times slower. That means that a compiler change that causes a failure of inference and a 100x performance regression is not a breaking change. So, these happens.</p> <p>I mean, don&#39;t get me wrong, they don&#39;t happen <em>often</em>, and they usually only affect part of your program, so the regression is rarely that dramatic. The Julia team really tries to avoid regressions like that, and they&#39;re usually picked up and fixed on the master branch of Julia before they make it to any release. Still, if you&#39;ve maintained a few Julia packages, I bet it has happened to you more than once.</p> <h2 id=the_ecosystem_is_immature ><a href="#the_ecosystem_is_immature" class=header-anchor >The ecosystem is immature</a></h2> <p>A more important consequence of Julia being a young, immature language is that the package ecosystem is similarly immature. Compared to the core language, which have a huge number of users, and more developers, the ecosystem settles more slowly. This has several consequences for Julia:</p> <p>First, compared to established languages, lots of packages are missing. Especially if you work in a niche subject, as most scientists do, you are much more likely to find a Python or R package to fit your needs than a Julia package. This situation will obviously improve over time, but right now, Julia is still quite far behind.</p> <p>You&#39;re also much more likely to find outdated or unmaintained packages in Julia. This is not because Julia packages tend to fall into disrepair more quickly than other languages, I think, but rather because packages which has already existed for 20 years are more likely to last another five more years than packages that have existed for two years. It&#39;s only been three years since Julia 1.0 came out, so if you find a blog post from 2015, any posted Julia code is unlikely to work, and the packages have probably released several breaking changes since then. In comparison, the Python package Numpy has been around five times longer than Julia 1.0&#33;</p> <p>In software ecosystems, it also takes a while for effort to consolidate to well-known packages. In Python, everybody knows, for example, to use <code>pandas</code> when working with dataframes. It has become the de-facto standard. And if it is to be dethroned, any contender must compare favorably against <code>pandas</code>, which means it must itself be a solid, well-used package. In Julia, it&#39;s not too rare to want a functionality and find three packages that do it in slightly different ways, all of them immature and light on features.</p> <p>Perhaps most critically, the developer tooling surrounding Julia is also immature, with lots of basic functionality missing. This is also a consequence of the ecosystem simply not being mature enough, with too little development effort behind it &#40;notably, no large companies have made large contributions to Julia, unlike every other language I know of&#41;. Here are a few examples, haphazardly chosen:</p> <ul> <li><p>Julia&#39;s built-in <code>Test</code> package is barebones, and does not offer setup and teardown of tests, nor the functionality to only run a subset of the full test suite. This is by design, but there does not exist a common go-to testing package that offers what the stdlib package lacks.</p> <li><p>The editor experience is not great with Julia. It&#39;s getting better, but with the foremost Julia IDE developed by a few people in their spare time, it has all the crashes, slowness and instability you would expect.</p> <li><p>Static analysis is brand new, and feels like it hasn&#39;t yet settled into its final form. It also has no IDE integration.</p> <li><p>There is no common framework for benchmarking and profiling Julia code. In a single session, you may analyze the same function with <code>BenchmarkTools</code>, <code>@allocated</code>, <code>Profile</code>, <code>JET</code>, <code>JETTest</code>, <code>@code_native</code> and <code>Cthulhu</code>, which each has to be loaded and launched individually. This issue is particularly notable when a new user faces performance issues and ask a Julia forum &quot;what should I do&quot;, and get 10 <em>different</em> answers, each concerning one specific sub-analysis that may cast light on one particular cause of performance problems. This is a huge time sink, and not a great user experience. It should be possible to gather several of these tools in a single analysis package, but it has not yet been done.</p> </ul> <h2 id=the_type_system_works_poorly ><a href="#the_type_system_works_poorly" class=header-anchor >The type system works poorly</a></h2> <p>This is the most controversial of my problems with Julia. People who don&#39;t know Julia have no idea what I mean when I say the subtyping system is bad, and people who <em>do</em> know Julia are unlikely to agree with me. I&#39;ll give a brief recap of how the system works for anyone not familiar:</p> <p>In Julia, types can be either <em>abstract</em> or <em>concrete</em>. Abstract types are considered &quot;incomplete&quot;. They can have subtypes, but they cannot hold any data fields or be instantiated - they are incomplete, after all. Concrete types can be instantiated and may have data, but cannot be subtyped since they are final. Here is an imaginary example:</p> <div class=juliacode ><pre><code class=language-julia ># Abstract type subtyping BioSequence &#40;itself abstract&#41;
abstract type NucleotideSequence &lt;: BioSequence end

# Concrete types with fields subtyping NucleotideSequence
# cannot be subtyped&#33;
struct DNASequence &lt;: NucleotideSequence
    x::Vector&#123;DNA&#125;
end</code></pre></div> <p>You can define methods for abstract types, which are inherited by all its subtypes &#40;that is, <em>behaviour</em> can be inherited, but not <em>data</em>&#41;. But if a concrete type define the same method, that will overwrite the abstract one:</p> <div class=juliacode ><pre><code class=language-julia ># Generic function, is slow
function print&#40;io::IO, seq::NucleotideSequence&#41;
    for i in seq
        print&#40;io, i&#41;
    end
end

# Specialized function, overwrites generic
function print&#40;io::IO, seq::DNASequence&#41;
    write&#40;io, seq.x&#41; # optimized write implementation
end</code></pre></div> <p>So you can create type hierarchies, implement generic fallback methods, and overwrite them whenever you want. Neat&#33; What&#39;s not to like? Well...</p> <h3 id=you_cant_extend_existing_types_with_data ><a href="#you_cant_extend_existing_types_with_data" class=header-anchor >You can&#39;t extend existing types with data</a></h3> <p>Say you implement some useful <code>MyType</code>. Another package thinks it&#39;s really neat and wants to extend the type. Too bad, that&#39;s just not possible - <code>MyType</code> is final and can&#39;t be extended. If the original author didn&#39;t add an abstract supertype for <code>MyType</code> you&#39;re out of luck. And in all probability, the author didn&#39;t. After all, good coders usually follow the <a href="https://en.wikipedia.org/wiki/You_aren&#37;27t_gonna_need_it">YAGNI</a> principle: Don&#39;t pre-emptively implement what you don&#39;t need.</p> <p>In e.g. Python, you are not going to run into types you want to subclass, but can&#39;t. You can subclass whatever you damn well please. In Rust, the problem is not even recognizable: Any type you write can freely derive traits and is not at all constrained by where it is placed in the type hierarchy, because there <em>is</em> no type hierarchy.</p> <h3 id=abstract_interfaces_are_unenforced_and_undiscoverable ><a href="#abstract_interfaces_are_unenforced_and_undiscoverable" class=header-anchor >Abstract interfaces are unenforced and undiscoverable</a></h3> <p>Suppose, on the other hand, you find out the author <em>did</em> actually add <code>AbstractMyType</code>. Then you can subtype it:</p> <div class=juliacode ><pre><code class=language-julia >struct YourType &lt;: AbstractMyType
    &#91; stuff &#93;
end</code></pre></div> <p>... and now what? What do you need to implement? What does the abstract type require? What does it guarantee? Julia offers absolutely no way of finding out what the abstract interface is, or how you conform to it. In fact, even in Base Julia, fundamental types like <code>AbstractSet</code>, <code>AbstractChannel</code>, <code>Number</code> and <code>AbstractFloat</code> are just not documented. What actually <em>is</em> a <code>Number</code>, in Julia? I mean, we know what a number is conceptually, but what are you opting in to when you subtype <code>Number</code>? What do you promise? Who knows? Do even the core developers know? I doubt it.</p> <p>A few abstract types in Julia <em>are</em> well documented, most notably <code>AbstractArray</code> and its abstract subtypes, and it&#39;s probably no coindidence that Julia&#39;s array ecosystem is so good. But this is a singular good example, not the general pattern. Ironically, this exception is often held up as an example of why the Julia type system <em>works well</em>.</p> <p>Here is a fun challenge for anyone who thinks &quot;it can&#39;t be that bad&quot;: Try to implement a <code>TwoWayDict</code>, an <code>AbstractDict</code> where if <code>d&#91;a&#93; &#61; b</code>, then <code>d&#91;b&#93; &#61; a</code>. In Python, which has inheritance, this is trivial. You simply subclass <code>dict</code>, overwrite a handful of its methods, and everything else works. In Julia, you have to define its data layout first - of course, you can solve this by simply creating a type that simply wraps a <code>Dict</code>, but the real pain of the implementation come when you must somehow figure out everything <code>AbstractDict</code> promises &#40;good luck&#33;&#41; and implement that.</p> <h3 id=subtyping_is_an_all-or-nothing_thing ><a href="#subtyping_is_an_all-or-nothing_thing" class=header-anchor >Subtyping is an all-or-nothing thing</a></h3> <p>Another problem with relying on subtyping for behaviour is that each type can only have one supertype, and it inherits <em>all</em> of its methods. Often, that turns out to not be what you want: New types often has properties of several interfaces: Perhaps they are set-like, iterable, callable, printable, etc. But no, says Julia, pick <em>one</em> thing. To be fair, &quot;iterable&quot;, &quot;callable&quot; and &quot;printable&quot; are so generic and broadly useful they are not implemented using subtyping in Julia - but doesn&#39;t that say something?</p> <p>In Rust, these properties are implemented through traits instead. Because each trait is defined independently, each type faces a smorgasbord of possibilities. It can choose <em>exactly</em> what it can support, and nothing more. It also leads to more code reuse, as you can e.g. simply derive <code>Copy</code> and get it without having to implement it. It also means there is an incentive to create &quot;smaller&quot; traits. In Julia, if you subtype <code>AbstractFoo</code>, you opt in to a potentially huge number of methods. In contrast, it&#39;s no problem to create very specific traits that concerns only a few - or one - method.</p> <p>Julia <em>does</em> have traits, but they&#39;re half-baked, not supported on a language level, and haphazardly used. They are usually implemented through multiple dispatch, which is also annoying since it can make it difficult to understand what is actually being called. Julia&#39;s broadcasting mechanism, for example, is controlled primarily through traits, and just finding the method ultimately being called is a pain.</p> <p>Also, since so much of Julia&#39;s behaviour is controlled through the type of variables instead of traits, people are tempted to use wrapper types if they want type <code>A</code> to be able to behave like type <code>B</code>. But those are <a href="https://github.com/JuliaLang/julia/issues/37790">a terrible idea</a>, since it only moves the problem and in fact makes it worse: You now have a new wrapper type you need to implement everything for, and even if you do, the wrapper type is now of type <code>B</code>, and doesn&#39;t have access to the methods of <code>A</code>&#33;</p> <p>A good example of the subtyping system not working is Julia&#39;s standard library <code>LinearAlgebra</code>. This package uses both wrapper types and traits to try to overcome the limitations of the type system, and suffers from both the workarounds. But an even clearer example of the failure of the type system is its use of <em>big unions</em>, that is, functions whose type signature has arguments of the type &quot;A or B or C or D or E or ...&quot;. These typically appear in code when you need to add a method to an object, and then discover that the sets of types you need to implement it for doesn&#39;t fit into the type hierarchy as a single supertype. And why would it? Why is it simply assumed that behaviour is strictly <a href="https://en.wikipedia.org/wiki/Monophyly">monophyletic?</a> Besides being unwieldly, unions are also un-extendable. And even in Base Julia, those unions can get out of control: If you have Julia at hand, try to type in <code>LinearAlgebra.StridedVecOrMat</code> and watch the horror. The use of such an abomination is a symptom of an unsolved underlying problem with the type system.</p> <p>The consensus on idiomatic Julia seem to be slowly drifting away from leaning on its type system to specify constraints, and towards ducktyping and traits. I essentially see this as the community implicitly beginning to acknowledge the problems of the type system and trying to avoid it where possible. All the individual gripes in the post about the system are well known, even if few people would grant the system as whole is poor. It has, however, been remarkably hard to provide good alternatives or solve the individual pain points. As Julia is maturing, there is less and less space to re-invent or enhance something as core as the type system.</p> <p>I expect that in the future, Julians will move even further towards Python-esque ducktyping. I predict that while there will arise packages that try to address some of these issues, they will be in disagreement about what to do, they will be niche, without good core language support, and therefore not really solve the problem.</p> <h2 id=the_iterator_protocol_is_weird_and_too_hard_to_use ><a href="#the_iterator_protocol_is_weird_and_too_hard_to_use" class=header-anchor >The iterator protocol is weird and too hard to use</a></h2> <h3 id=the_protocol ><a href="#the_protocol" class=header-anchor >The protocol</a></h3> <p>By &quot;the iterator protocol&quot;, I mean: How does a for loop work? The three languages I&#39;m familiar with, Python, Rust and Julia, all handle this slightly different. In Julia, the following code:</p> <div class=juliacode ><pre><code class=language-julia >for i in x
    # stuff
end</code></pre></div> <p>lowers into something equivalent to:</p> <div class=juliacode ><pre><code class=language-julia >itval &#61; iterate&#40;x&#41;
while itval &#33;&#61;&#61; nothing
    i, state &#61; itval
    # stuff
    itval &#61; iterate&#40;x, state&#41;
end</code></pre></div> <p>This means that, to implement an iterator, you need to implement <code>iterate&#40;x&#41;</code> and <code>iterate&#40;x, state&#41;</code>. It should return <code>nothing</code> when the iteration is done, and <code>&#40;i, next_state&#41;</code> when it still has elements. By the way, you <em>also</em> need to implement a few traits, which Julia does not warn you about if you forget, or implement them wrongly. But <a href="#abstract_interfaces_are_unenforced_and_undiscoverable">I gripe about that elsewhere</a>.</p> <p>So: Why is it like that? Well, <a href="https://mikeinnes.github.io/2020/06/04/iterate.html">I&#39;m not the only one to wonder</a>. At least one of the reasons it was designed like that is that it makes the <code>iterate</code> function and the iterator itself <em>stateless</em>, since the state is stored in the local variable passed as an argument to the <code>iterate</code> function. It means you can&#39;t have bugs like this Python bug:</p> <div class=pythoncode ><pre><code class=language-python >&gt;&gt;&gt; iter &#61; &#40;i&#43;1 for i in range&#40;3&#41;&#41;
&gt;&gt;&gt; length &#61; sum&#40;1 for i in iter&#41;
&gt;&gt;&gt; list&#40;iter&#41; # oops&#33;
&#91;&#93;</code></pre></div> <h3 id=the_problem ><a href="#the_problem" class=header-anchor >The problem</a></h3> <p>First, you <em>absolutely</em> can have the same bug as in Python, because <em>some</em> iterators <em>are</em> stateful&#33; For example, if you read a file:</p> <div class=juliacode ><pre><code class=language-julia >julia&gt; lines &#61; eachline&#40;&quot;my_file.txt&quot;&#41;;

julia&gt; n_lines &#61; count&#40;x -&gt; true, lines&#41;;

julia&gt; collect&#40;lines&#41;
String&#91;&#93;</code></pre></div> <p>And since there is no way of knowing programatically &#40;and certainly not statically&#41; if an iterator is stateful, you better adopt a coding style that assumes all iterators are stateful, anyway.</p> <p>To be clear, the <em>problem</em> isn&#39;t that Julia has stateless iterators. Stateless iterators have advantages, they may in fact be superior and preferable where possible. The real problem is that <em>iteration is never stateless</em> - in a loop, there <em>must</em> always be state. When using stateless iterators, the problem of keeping track of the state is not solved, but simply moved elsewhere. Julia&#39;s iterators are &quot;stateless&quot; in the worst possible sense of the word: That the compiler and the language doesn&#39;t know about state, and therefore offloads the job of keeping track of it to the programmer. Reasoning about state across time is a famously hard problem in programming, and with Julia&#39;s iterators, you get to feel 100&#37; of that pain.</p> <p>Making the compiler&#39;s job easier by offloading work to the programmer is not how high-level languages are supposed to work&#33; The solution, at least not being a Julia developer, seems obvious. Iteration should instead lower to</p> <div class=juliacode ><pre><code class=language-julia >itr &#61; iterator&#40;x&#41;
while &#40;i &#61; next&#40;itr&#41;&#41; &#33;&#61;&#61; nothing
    # stuff
end</code></pre></div> <p>This is how Rust and Python works, approximately. Notice the code is simpler than what Julia acutally lowers to. The big advantage, however, is that the state is stored in the <code>itr</code> object, and doesn&#39;t need to be manually handled or passed around by the person implementing the iterations. Interestingly, it already solves the problem of stateful iterators that Julia&#39;s solution is meant to address, since the iterator is reset on the call to <code>iterator</code>.</p> <p>What are the problems with passing around state with the current approach? Suppose you create an iterator that you need to process in two stages: First, you do some initialization with the first elements of the iterator. Perhaps it&#39;s an iterator of lines and you need to skip the header. After that, you iterate over the remaining arguments. You implement this as the functions <code>parse_header</code> and <code>parse_rest</code> In Julia, <em>you need to explicitly pass state</em> between the functions as an argument - not to mention all the boilerplate code it introduces because <code>parse_rest</code> now can&#39;t use a for loop to iterate, since that would &quot;restart&quot; the iterator. Well, <em>maybe</em> it would, who knows if it&#39;s stateless&#33;</p> <p>If you&#39;re a Julian reading this with scepticism, try implementing an interleaving iterator: It should take any number of iterators <code>x1, x2, ... xn</code> and produce a stream of their interleaved values: <code>x1_1, x2_x1, ... nx_1, x1_2 ... xn_m</code>. Easy peasy in Python, a headache in Julia because you have to juggle N states manually in the function. Or try re-implementing <code>zip</code> or a roundrobin iterator.</p> <h2 id=functional_programming_primitives_are_not_well_designed ><a href="#functional_programming_primitives_are_not_well_designed" class=header-anchor >Functional programming primitives are not well designed</a></h2> <p>I didn&#39;t really notice this until I tried Rust, and Julia&#39;s <code>Transducers</code> package, both of whom implements the foundations of functional programming &#40;by this I mean map, filter etc.&#41; way better than Julia itself does. This issue is not <em>one single</em> design problem, but rather a series of smaller issues about how Julia&#39;s iterators are just... generally not that well designed.</p> <p><code>map</code>, <code>filter</code> and <code>split</code> are eager, returning <code>Array</code>. There is <em>literally</em> no reason for this - it only makes the code slower and less generic. I can&#39;t think of a single upside - perhaps other than that it saves you typing <code>collect</code> once in a while. Newer versions of Julia introduced <code>Iterators.map</code> and <code>Iterators.filter</code> which <em>are</em> lazy, but using them means breaking backwards compatibility, and also, you have to use the ugly identifier <code>Iterators</code>. And for <code>split</code>, there is no such escape hatch - you just have to accept it&#39;s slow and unnecessarily allocating.</p> <p>Functional programming functions like <code>map</code> and <code>filter</code> can&#39;t take functions. That is, I cannot call <code>map&#40;f&#41;</code> and get a &quot;mapper&quot; function. I usually &quot;solve&quot; this by defining <code>imap&#40;f&#41; &#61; x -&gt; Iterators.map&#40;f, x&#41;</code> in the beginning of my files, but honestly, Julia&#39;s iterators should work like this by default.</p> <p>But Jakob, you say, don&#39;t you know about Takafumi Arakaki&#39;s amazing <code>JuliaFolds</code> ecosystem which reimagines Julia&#39;s iterator protocol and functional programming and gives you everything you ask for? Yes I do, and it&#39;s the best thing since sliced bread, BUT this basic functionality simply <em>can&#39;t</em> be a package. It <em>needs</em> to be in Base Julia. For example, if I use Arakaki&#39;s packages to create an &quot;iterator&quot;, I can&#39;t iterate over it with a normal Julia for loop, because Julia&#39;s for loops lower to calls to <code>Base.iterate</code>. Also, because <code>JuliaFolds</code> is not Julia&#39;s default iterator implementation, and therefore sees less usage and development than Julia&#39;s built-in iterators, the package suffers from some compiler inference issues and obscure errors.</p> <h2 id=misc_gripes ><a href="#misc_gripes" class=header-anchor >Misc gripes</a></h2> <h3 id=there_is_no_path_type ><a href="#there_is_no_path_type" class=header-anchor >There is no Path type...</a></h3> <p>When Julia was first being written, the core devs more or less copied Python&#39;s path API directly. Of all the languages you could have imitated, you could have picked worse than Python - the language usually has a sane, pleasant API. Unfortunately, for path specifically, Julia also inherited Python&#39;s sin of using strings to represent filenames and paths. Since Julia is otherwise pretty good about being strongly typed, this design decision is unfortunate.</p> <p>&quot;What&#39;s the problem&quot;, you might ask, &quot;aren&#39;t paths just strings applied to the filesystem?&quot; No, they <em>absolutely aren&#39;t</em>. Paths may be printed like a string, and may even use a string as internal storage, but that is incidental: Paths are <em>conceptually different</em> from strings, and need their own type. <code>DateTime</code>s are represented by an <code>Int</code>, but are <em>not</em> integers, and <code>Char</code>s are not 32-bit integers even if they can be represented by them. The important thing is not what they look like to the CPU, but how the behave to the programmer. </p> <p>Conflating the behaviour of strings and paths just because they look similar is an example of weak typing, causes a bunch of problems:</p> <p>First, linting and static analysis of paths become limited because you can&#39;t specify that a particular value is a path, and that you shouldn&#39;t try to convert it to titlecase it or reverse it, or something silly like that. That same lack of information extends to the programmer: The behaviour of an argument annotated as <code>AbstractPath</code> is immediately obvious, whereas it&#39;s not clear that an <code>AbstractString</code> actually represents a path. I&#39;ve seen real code where the same value encoded as a <code>String</code> could refer to <em>either</em> a URL, or a path, depending on the current state of the function, leaving it up to the programmer to keep track of what type the value <em>really</em> was at any given time.</p> <p>Second, and more importantly, it means lots of functionality simply isn&#39;t implemented for paths in Julia, because the developers never had the need, as they could just get away with using strings: How do you verify a path is validly formatted on your system? How can you tell if a path is relative? These questions, and more, are basically unanswered in Julia, because every developer needs to implement solutions for these issues by themselves, in every application.</p> <p>In contrast, if there were a single <code>Path</code> type, its constructor would be validating, and all the weird and annoying edge cases about paths would need to be encoded into the object at the type level, making things much easier for developers. Again, it&#39;s hard not to look at Rust for a great example. Rust&#39;s paths are complicated to deal with, because <em>paths are complicated to deal with</em>. But the complexity is tackled head-on, and most of the hard stuff had already been done for you by better programmers.</p> <p>Last, it&#39;s pretty remarkable that the functions that operate on Julia&#39;s paths all have names like <code>isabspath</code>, <code>isdirpath</code>, <code>joinpath</code>, <code>mkpath</code>, <code>normpath</code>, <code>splitpath</code> etc - all containing the word <code>path</code>. Essentially no other Julia functions are named like that: We have no <code>transposematrix</code>, <code>mulnumber</code>, <code>reversestring</code>, <code>maparray</code>. Why don&#39;t we? Because, when you start to encode type information into your function names, it should be obvious that you need a new type.</p> <p>Speaking of which, what do you do when a function has two plausible meanings depending on whether the argument is a string or a path? For example, the method <code>countlines&#40;::String&#41;</code> could either count the lines in the string, or it could treat the string as a path and count the lines in the file at that path. Remarkably, and counter-intuitively, it does the latter. I guess the path-implementation was just finished first, and now the former cannot be implemented because the method is already taken.</p> <p>&quot;But there&#39;s a package for paths&#33;&quot;, you say. Right, <code>FilePathsBase</code>. How many use it, again? Certainly few enough that it&#39;s the nonstandard solution. And as of this moment, I consider the package is too rough around the edges for general use, with e.g. type instability everywhere. For basic things like paths, it&#39;s essentially not good enough for there to be a package, unless the package is so standard it might as well be in the standard library.</p> <h3 id=and_no_option_type ><a href="#and_no_option_type" class=header-anchor >..and no Option type</a></h3> <p>All languages has to deal with the concept of &quot;this function either gives some result, or no result at all&quot;. For example, <code>findfirst</code> on arrays returns the first index of an array where some predicate is satisfied - or nothing, if there is no such index. Historically, languages has dealt with an absence of a proper result differently: Return codes, special magic values, or by throwing exceptions that are expected to get caught &#40;e.g. Python&#39;s <code>StopIteration</code>&#41;.</p> <p>At this point in time, I think it is clear that the best solution to this problem is returning a value with the success encoded in the type system, like e.g. Haskell/Clojure&#39;s <code>Maybe</code>, or Rust&#39;s <code>Option&lt;T&gt;</code>. These kinds of types are called <em>sum types</em> &#40;or <em>tagged unions</em>&#41;. Annoyingly, Julia does not have such types.</p> <p>Well, it <em>kind of</em> does... sort of. Julia has union types, and it&#39;s custom for these failable functions to return <code>Union&#123;T, Nothing&#125;</code>. The advantages and disadvantages of union types versus sum types is a whole topic on its own, so I&#39;ll just touch on two problems with Julia&#39;s approach here.</p> <p>First, sum types <em>forces</em> the user to deal with potential failure, because the result needs to be unwrapped, whereas union types can hide the error state, such that it seemingly works, until it suddenly doesn&#39;t. Which happens a lot in Julia - even Base Julia had, until the advent of static type checking, lots of places where these failure states were not handled. My positive experience with sum types after learning Rust led me to create <a href="https://github.com/jakobnissen/ErrorTypes.jl">ErrorTypes.jl</a>, but being a package, it obviously only works for code that chooses to use it.</p> <p>Second, sometimes, <code>nothing</code> is used as a valid return value in Julia, and then this union-type scheme comes crashing down, because <code>Union&#123;Nothing, Nothing&#125;</code> is just <code>Nothing</code>&#33; In other words, it is impossible to distinguish between a function returning &quot;no result&quot; and &quot;the result <code>nothing</code>&quot;. The standard solution when <code>nothing</code> can be a valid result is to instead return <code>Union&#123;Some&#123;T&#125;, Nothing&#125;</code> as the return value. But of course, the person implementing the function often does not know whether <code>nothing</code> can be a valid value&#33;</p> <p>For example, suppose <code>d</code> is a <code>Dict&#123;Any, Int&#125;</code>, and I check for odd-numbered values by doing <code>findfirst&#40;isodd, d&#41;</code>, and it returns <code>nothing</code>. It is impossible to tell if the key <code>nothing</code> had an odd value, or if there were no odd-valued keys.</p> <div class=page-foot > <div class=copyright > Jakob Nybo Nissen. Last modified: November 27, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> <script src="/libs/highlight/highlight.pack.js"></script> <script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: ' '});</script>