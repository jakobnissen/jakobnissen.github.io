<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/basic.css"> <link rel=icon  href="/assets/v.svg"> <title>Advent of Code 2021, day 1</title> <header> <div class=blog-name ><a href="/">viralinstruction</a></div> <nav> <ul> <li><a href="/">Home</a> <li><a href="/about/">About</a> <li><a href="/feed.xml">RSS</a> </ul> <img src="/assets/hamburger.svg" id=menu-icon > </nav> </header> <div class=franklin-content ><h1 id=advent_of_code_2021_day_1 ><a href="#advent_of_code_2021_day_1" class=header-anchor >Advent of Code 2021, day 1</a></h1> <p><em>Written 2021-12-01</em></p> <p>This year&#39;s <a href="https://adventofcode.com/">Advent of Code</a> has begun, meaning that ♪&#39;tis the season to be coding♪. AoC is a <em>great</em> opportunity to learn a new programming language or new set of programming tools. For example, you could use this year&#39;s AoC to learn... oh, I don&#39;t know, <a href="https://julialang.org/">Julia</a>?</p> <p>Great choice&#33; You&#39;ve come to the right place. In this post, I will be showing you how I&#39;ve solved <a href="https://adventofcode.com/2021/day/1">the day 1 puzzle</a> in Julia.</p> <p>A fair warning though: The day 1 puzzle is not very challenging. But because this post is <em>really</em> about how best to get started coding a project using Julia, with unit tests and benchmarks and the whole shebang, the solution will be wildly over-engineered. Don&#39;t let the takeaway be that causal programming in Julia requires all this setup.</p> <p>You can find the code <a href="https://github.com/jakobnissen/AoC2021">here &#40;click&#41;</a>.</p> <h2 id=setting_up_your_project ><a href="#setting_up_your_project" class=header-anchor >Setting up your project</a></h2> <p>You&#39;ll want to <a href="https://julialang.org/downloads/#current_stable_release">install Julia first</a> &#40;of course&#41;, and some kind of editor. I recommend <a href="https://code.visualstudio.com/">VS Code</a>, because it currently has the best Julia IDE, but editors can be an, uh, <a href="https://en.wikipedia.org/wiki/Editor_war">touchy subject</a>, so you just pick your favourite. If you choose VS Code you&#39;ll also want to install the <a href="https://www.julia-vscode.org/">julia extension</a> - just get the extension called &quot;julia&quot;.</p> <p>To solve the 24 Advent of Code puzzles, We <em>could</em> just make a series of scripts, but let&#39;s do it the <em>right</em> way and instead create a new Julia project for this year&#39;s AoC. We can then have one source file per day. To do this, launch Julia, then type <code>&#93;</code> to enter <code>Pkg</code> mode, then type:</p> <div class=juliacode ><pre><code class="plaintext hljs">(@v1.7) pkg&gt; generate AoC2021
  Generating  project AoC2021:
    AoC2021/Project.toml
    AoC2021/src/AoC2021.jl</code></pre></div> <p>This is the part where some people grimace in disgust: I&#39;m using <em>the REPL</em> to initialize a project from within Julia? Why not simply do it from the shell?</p> <p>Right, about that... When developing Julia, it is <em>possible</em> to run all your commands from the shell, but I strongly recommend you don&#39;t do that, and work from the REPL instead. For some people, this may be a jarring shift in your normal development workflow, I know. But when in Rome, do as the Romans - Julia&#39;s development experience really does work better when you interact with it from the REPL. If it makes it easier, you can use the Julia REPL in the VSCode terminal.</p> <p>With your open REPL, navigate to the <code>AoC2021</code> directory you just created &#40;type <code>;</code> to enter shell mode, navigate to the path and hit backspace to exit to REPL mode&#41;, enter package mode and execute <code>activate .</code> &#40;note the trailing dot for &quot;this directory&quot;&#33;&#41; to have the package manager activate the project. If it works, you should see the prompt look like</p> <div class=juliacode ><pre><code class="plaintext hljs">(AoC2021) pkg&gt;</code></pre></div>
<p>You can then use backspace to get back to the <code>julia&gt;</code> REPL mode. Okay, so currently our directory looks like:</p>
<div class=shellcode ><pre><code class="plaintext hljs">$ exa -T
.
├── Project.toml
└── src
   └── AoC2021.jl</code></pre></div>
<p>Let&#39;s add a <code>data</code> directory and add today&#39;s input file in that. We also add a new <code>day01.jl</code> file in the <code>src</code> directory for today&#39;s code, and make the toplevel project file <code>AoC2021.jl</code> file <code>include</code> the new file. The directory structure is now:</p>
<div class=shellcode ><pre><code class="plaintext hljs">$ exa -T
.
├── data
│  └── day01.txt
├── Project.toml
└── src
   ├── AoC2021.jl
   └── day01.jl</code></pre></div>
<p>And the main file <code>AoC2021.jl</code> contains:</p>
<div class=juliacode ><pre><code class="plaintext hljs">module AoC2021

include(&quot;day01.jl&quot;)

end # module</code></pre></div>
<p>Let&#39;s also make the directory a git repository - that&#39;s always a good idea when developing:</p>
<div class=shellcode ><pre><code class="plaintext hljs">$ git init</code></pre></div>
<p>and add the following to <code>.gitignore</code>:</p>
<div class=shellcode ><pre><code class="plaintext hljs">/data</code></pre></div>
<p>We don&#39;t want to waste <em>kilobytes</em> by tracking the data directory &#40;and in any case, different people get different challenge inputs&#41;. Normally, when developing Julia packages, we would also ignore the <code>Manifest.toml</code> file which we will soon create with the Julia package manager. See where the <code>Project.toml</code> file is used the specify dependencies and compatibility bounds for a package, <code>Manifest.toml</code> contains the resolved dependency graph of the project. If you are familiar with Rust, <code>Project.toml</code> and <code>Manifest.toml</code> correspond to <code>Cargo.toml</code> and <code>Cargo.lock</code>, respectively. The <code>Manifest.toml</code> file can be used if the user needs to reconstruct an environment <em>precisely</em>, for example when doing reproducible science. When developing packages, you usually <em>don&#39;t</em> want to completely specify an environment. Instead you want your package to be usable in a broad range of environments. And so, normally, the manifest is ignored with version control.</p>
<p>However, in our case, an Advent of Code challenge is one of those cases where you might want to have the full environment, so here, we keep the manifest.</p>
<p>Now, we can begin to look at today&#39;s challenge. The structure of the file <code>day01.jl</code> will be like this:</p>
<div class=juliacode ><pre><code class="plaintext hljs">module day01

function solve(io::IO)
    # code goes here...
end

end # module</code></pre></div>
<p>Such that the function can accept any IO-like argument - this could be a string, or a file-like object. To create more generic code, I could also just have left off the type annotation <code>::IO</code> altogether, but we really do only want to call it on IO inputs, and the type annotation can serve as self-documenting code.</p>
<p>If you are using VSCode with the <code>julia</code> extension, it will automatically load a bunch of Julia packages related to development &#40;incidentally, this is why the editor is somewhat slow to start&#41;. For example, it loads <a href="https://github.com/timholy/Revise.jl">Revise.jl</a>, a near-obligatory package which tracks changes to your code and reloads any changed code automatically. If you are not using VSCode, I highly highly recommend installing Revise. You don&#39;t want to install Revise into your <em>current</em> project, making it a dependency. Instead, enter your default environment, install it there, and then return to the AoC2021 environment.</p>
<div class=juliacode ><pre><code class="plaintext hljs">(AoC2021) pkg&gt; activate
  Activating environment at `~/.julia/environments/v1.7/Project.toml`
  
(@v1.7) pkg&gt; add Revise
 [ OUTPUT ELIDED ]

(@v1.7) pkg&gt; activate .
  Activating project at `~/code/AoC2021`

(AoC2021) pkg&gt;</code></pre></div>
<p>Then, to start developing, open the REPL and type </p>
<div class=juliacode ><pre><code class="plaintext hljs">julia&gt; using Revise

julia&gt; using AoC2021</code></pre></div>
<h2 id=the_code_itself ><a href="#the_code_itself" class=header-anchor >The code itself</a></h2>
<p>So, for part 1, I have a list of numbers that looks like this:</p>
<div class=shellcode ><pre><code class="plaintext hljs">199
200
208
210
200
207
240
269
260
263</code></pre></div>
<p>And I need to count how many numbers are larger than the previous number - in this case 7. Let&#39;s have this list of numbers in the source code for day 1, then we can also use it as a test case:</p>
<div class=juliacode ><pre><code class="plaintext hljs">const TEST_STRING = &quot;&quot;&quot;199
200
208
210
200
207
240
269
260
263&quot;&quot;&quot;</code></pre></div>
<p>To solve any problem, it&#39;s a good idea to break it down. First, I need to parse it from a text file into a list of numbers. To find suitable functions in Base Julia, you can search the online documentation &#40;which also exists locally in your Julia install&#41;, or you can use the function <code>apropos</code> in the REPL to search through docstrings.</p>
<p>In this case, I need <code>parse</code> and <code>eachline</code>:</p>
<div class=juliacode ><pre><code class="plaintext hljs">function solve(io::IO)
    v = [parse(Int, line) for line in eachline(io)]
end</code></pre></div>
<p>When I have some approach I think may work, I test it out in the REPL:</p>
<div class=juliacode ><pre><code class="plaintext hljs">julia&gt; AoC2021.day01.solve(IOBuffer(AoC2021.day01.TEST_STRING))
10-element Vector{Int64}:
 199
 200
 208
 210
 200
 207
 240
 269
 260
 263</code></pre></div>
<p>That looks right.</p>
<p>Okay, now to answer the question by comparing consecutive numbers. What immediately springs to mind is the old Python idiom for getting consecutive pairs in a list:</p>
<div class=pythoncode ><pre><code class="plaintext hljs">&gt;&gt;&gt; zip(v, v[1:])</code></pre></div>
<p>We can translate that to Julia, and use <code>sum</code> with a generator expression to get the result, just like I would in Python:</p>
<div class=juliacode ><pre><code class="plaintext hljs">function solve(io::IO)
    v = [parse(Int, line) for line in eachline(io)]
    sum(next &gt; prev for (prev, next) in zip(v, v[2:end]))
end</code></pre></div>
<p>Testing it in the REPL returns <code>7</code>, which is correct. I can now test it for the input:</p>
<div class=juliacode ><pre><code class="plaintext hljs">julia&gt; open(AoC2021.day01.solve, &quot;data/day01.txt&quot;)
1390</code></pre></div>
<p>Which happens to be the correct answer for me&#33;</p>
<h3 id=part_2 ><a href="#part_2" class=header-anchor >Part 2</a></h3>
<p>As always there is a twist: The puzzle now asks to count the number of sliding windows of size 3 for which the sum is larger than the previous sliding window&#33;</p>
<p>Instead of messing around with the actual windows, I notice that when the first window &#40;containing the numbers <code>&#40;v&#91;1&#93;, v&#91;2&#93;, v&#91;3&#93;&#41;</code>&#41; slides a slot to the window at indices 2, 3, and 4, the sum decreases by <code>v&#91;1&#93;</code> which is no longer part of the window, and increases by <code>v&#91;4&#93;</code>. So, the sum is larger iff <code>v&#91;4&#93; &gt; v&#91;1&#93;</code>. In other words, part 2 can be viewed just like part 1, except that we consider pairs of numbers with a distance of 4 instead of 1.</p>
<p>So the code just needs a slight modificiation from part 1:</p>
<div class=juliacode ><pre><code class="plaintext hljs">function solve(io::IO)
    v = [parse(Int, line) for line in eachline(io)]
    part1 = sum(next &gt; prev for (prev, next) in zip(v, v[2:end]))
    part2 = sum(next &gt; prev for (prev, next) in zip(v, v[4:end]))
    (part1, part2)
end</code></pre></div>
<p>And it works&#33; :&#41;</p>
<h2 id=adding_tests ><a href="#adding_tests" class=header-anchor >Adding tests</a></h2>
<h3 id=adding_test-specific_dependencies ><a href="#adding_test-specific_dependencies" class=header-anchor >Adding test-specific dependencies</a></h3>
<p>Of course, no project is complete without tests. We could use <a href="https://docs.julialang.org/en/v1/stdlib/Test/">Julia&#39;s built-in testing package</a>, but that is quite bare-bones. Instead, let us use <code>ReTest</code>, which allows us to write tests next to the source code the tests work on &#40;and much more&#41;.</p>
<p>We want <code>ReTest</code> as a dependency when <em>testing</em>, but for just running the code we don&#39;t need all the functionality of <code>ReTest</code>. We just need a package that allows tests to be written in-line. The smaller, lightweight package <code>InlineTest</code> will allow us to do that. So, we need <em>test-specific dependencies</em>: <code>ReTest</code> when testing, and <code>InlineTest</code> when running. How to do that?</p>
<p>First, add both packages as dependencies using the package manager:</p>
<div class=juliacode ><pre><code class="plaintext hljs">(AoC2021) pkg&gt; add ReTest@0.3, InlineTest@0.2</code></pre></div>
<p>I specify the versions explicitly to make sure the code in this post will remain functional in the future. Feel free to install the latest version.</p>
<p>Now, manually modify the <code>Project.toml</code> to specify test-specific dependencies. Currently, your file looks something like this:</p>
<pre><code class="plaintext hljs">name = &quot;AoC2021&quot;
uuid = &quot;10e8a67a-2997-442f-ba23-999a08daf998&quot;
authors = [&quot;Your Name &lt;youremail@domain.com&gt;&quot;]
version = &quot;0.1.0&quot;

[deps]
InlineTest = &quot;bd334432-b1e7-49c7-a2dc-dd9149e4ebd6&quot;
ReTest = &quot;e0db7c4e-2690-44b9-bad6-7687da720f89&quot;</code></pre>
<p>Change it so it looks like this:</p>
<pre><code class="plaintext hljs">name = &quot;AoC2021&quot;
uuid = &quot;10e8a67a-2997-442f-ba23-999a08daf998&quot;
authors = [&quot;Your Name &lt;youremail@domain.com&gt;&quot;]
version = &quot;0.1.0&quot;

[deps]
InlineTest = &quot;bd334432-b1e7-49c7-a2dc-dd9149e4ebd6&quot;

[compat]
julia = &quot;1.6&quot;
InlineTest = &quot;0.2&quot;
ReTest = &quot;0.3&quot;

[extras]
ReTest = &quot;e0db7c4e-2690-44b9-bad6-7687da720f89&quot;

[targets]
test = [&quot;ReTest&quot;]</code></pre>
<p>The notable differences are:</p>
<ul>
<li><p>Only <code>InlineTest</code> is listed as a dependency.</p>

<li><p>There are now compatibility bounds on all packages, including the Julia version. This will prevent your <code>AoC2021</code> package from being installed with incompatible packages, or in a Julia session running an incompatible Julia version. By default, SemVer is assumed, so using e.g. <code>InlineTest v 0.2.4</code> is fine, but <code>InlineTest 0.3.0</code> is not.</p>

<li><p>The <code>&#91;extras&#93;</code> and <code>&#91;test&#93;</code> sections list <code>ReTest</code> as a test-specific dependency.</p>

</ul>
<p>Unfortunately, as of Julia 1.7, you have to specify these compat bounds manually. It would be nicer if the Julia package manager automatically added SemVer-compatible compat bounds. Maybe someday, it will&#33;</p>
<h3 id=now_to_actually_write_the_test_code ><a href="#now_to_actually_write_the_test_code" class=header-anchor >Now to actually write the test code</a></h3>
<p>We import the package in the top-level file <code>AoC2021.jl</code>:</p>
<div class=juliacode ><pre><code class="plaintext hljs">module AoC2021

using InlineTest

include(&quot;day01.jl&quot;)

end # module</code></pre></div>
<p>and also import it at the top of the <code>day01</code> file using a relative import &#40;so it imports it from the top-level module&#41;:</p>
<div class=juliacode ><pre><code class="plaintext hljs">module day01

using ..InlineTest

[ rest of file elided ]</code></pre></div>
<p>We can now write a test set using the <code>@testset</code> macro, that makes sure our code works for the test data at least:</p>
<div class=juliacode ><pre><code class="plaintext hljs">@testset &quot;day01&quot; begin
    @test solve(IOBuffer(TEST_STRING)) == (7, 5)
end</code></pre></div>
<p>To test it, must have imported our module <code>AoC2021</code>. We also need to import <code>ReTest</code> &#40;install it in the default environment like you did <code>Revise.jl</code>, not in the current environment&#33;&#41; and run <code>AoC2021.runtests&#40;&#41;</code>:</p>
<div class=juliacode ><pre><code class="plaintext hljs">julia&gt; using ReTest

julia&gt; AoC2021.runtests()
                   Pass  
AoC2021.day01:
  day01        |      1</code></pre></div>
<h2 id=adding_static_analysis ><a href="#adding_static_analysis" class=header-anchor >Adding static analysis</a></h2>
<p>After having tested, we can be fairly sure it works as we expect. However, writing a comprehensive test suite that covers all the edge cases is difficult. To be a little more confident our program is well-behaved, we can analyze the behaviour statically. Of course for projects as tiny as Advent of Code day 1, there really isn&#39;t much point to static analysis, but let me show you anyway:</p>
<p>For this, I use the package <code>JET.jl</code>. Just like Revise, better not install this into the AoC2021 project, but instead into the default environment.</p>
<p>An interesting wrinkle when doing static analysis of Julia is that the program&#39;s behaviour is essentially un-analyzable until it is actually compiled, and it is not compiled until we run it - or at least give concrete input types to its functions. Therefore, unlike for static languages, it is mostly meaningless to try to analyze the <em>source code</em> of our file - instead, we have to analyze specific <em>uses</em> of the code.</p>
<p>Here, for example, I analyze on the type-level how the main function behaves when called with an <code>IOBuffer</code>:</p>
<div class=juliacode ><pre><code class="plaintext hljs">julia&gt; using JET

julia&gt; @report_call AoC2021.day01.solve(IOBuffer())
No errors !
Union{Nothing, Int64}</code></pre></div>
<p>No errors&#33; Whew&#33;</p>
<p>If you&#39;re using VSCode, <code>JET.jl</code> integrates with the editor and displays any errors in the <code>problems</code> pane &#40;or in this case, does nothing as there are no errors.&#41;</p>
<p>It would be possible to add <code>JET.jl</code> static analysis to the test suite. However, with the current state of static analysis in Julia, this is not advisable. Unlike static languages, the presence of a <em>potential</em> error - for example an unresolvable function call - may not be an actual problem in Julia code. For example, suppose we had a few dependencies, and the dependencies got updated. It would be completely fair game for these dependencies to now include code that is not statically inferrable, but which behaves correctly when running. It is therefore best to not include static analysis in automatic tests. Static analysis may be improved in future versions of Julia, but for now, we&#39;ll leave it as it is.</p>
<h2 id=benchmarking ><a href="#benchmarking" class=header-anchor >Benchmarking</a></h2>
<p>Wise programmers say that, most of the time, slow code is fast enough, and developers should optimize their code for maintainability instead of speed. That may be true, but that has never stopped me from over engineering otherwise uncomplicated software until it goes <em>brrrrrr</em>.</p>
<p>For benchmarking, we&#39;ll use the tested and tried <code>BenchmarkTools</code> package. Again, this shouldn&#39;t be a dependency of our actual project, so let&#39;s install it in our home environment:</p>
<div class=juliacode ><pre><code class="plaintext hljs">(AoC2021) pkg&gt; activate
  Activating environment at `~/.julia/environments/v1.7/Project.toml`

(@v1.7) pkg&gt; add BenchmarkTools
  [ output elided ]

(@v1.7) pkg&gt; activate .
  Activating environment at `~/code/AoC2021/Project.toml`</code></pre></div>
<p>Now we can benchmark a function call like so:</p>
<div class=juliacode ><pre><code class="plaintext hljs">julia&gt; @benchmark open(AoC2021.day01.solve, &quot;data/day01.txt&quot;)
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  264.768 μs …   3.268 ms  ┊ GC (min … max): 0.00% … 83.96%
 Time  (median):     283.136 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   296.689 μs ± 174.874 μs  ┊ GC (mean ± σ):  3.38% ±  5.22%

         ▁▅█▄
  ▂▂▃▃▅▆▇████▇▆▄▄▃▃▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▁▁▂▁▁▂▁▁▂▁▂▁▂▂▂▂▂▂▂▂▂▂ ▃
  265 μs           Histogram: frequency by time          384 μs &lt;

 Memory estimate: 179.92 KiB, allocs estimate: 4021.</code></pre></div>
<p>&#40;or get just the minimum time using <code>@btime</code>, where the output is less unwieldy&#41;. Those times include reading and parsing the input file. Not too unreasonable&#33;</p>
<p>Let&#39;s see where we can improve. The first thing that strikes me is that we allocate new vectors when we index into them using ranges. Let&#39;s change that to views.</p>
<p>Second, the <code>parse</code> function tries to autodetect the base, such that parsing of e.g. base 16 text works automatically. That&#39;s nice, but the check is a little slow, so let&#39;s specify the base is 10. This is also more correct, so that&#39;s nice.</p>
<p>Another issue is fold-based iterators like <code>sum</code>. Their behaviour is undefined for empty collections &#40;what&#39;s the sum of nothing?&#41;, so they throw an error in Julia. The potential to throw is both an edge case I ought to cover, and slows the code down a little. This can be prevented by setting the <code>init</code> keyword, giving it an initial value to start from.</p>
<p>Lastly, for some bizzare reason, iterating a view is inefficient in Julia compared to indexing. That really really ought to be fixed, but for now, let&#39;s change the <code>zip</code> iterator to a solution that uses indexing:</p>
<div class=juliacode ><pre><code class="plaintext hljs">function solve(io::IO)
    zipdiff(a, b) = sum((@inbounds b[i] &gt; a[i] for i in eachindex(b)), init=0)
    v = [parse(Int, line, base=10) for line in eachline(io)]
    return (zipdiff(v, @view v[2:end]), zipdiff(v, @view v[4:end]))
end</code></pre></div>
<p>And then</p>
<div class=juliacode ><pre><code class="plaintext hljs">julia&gt; @btime open(AoC2021.day01.solve, &quot;data/day01.txt&quot;);
  249.112 μs (4021 allocations: 179.92 KiB)</code></pre></div>
<p>That&#39;s, uh... basically no difference. A bit more benchmarking confirms that the gain is insignificant compared to the total runtime. Unfortunately, IO is the bane of Julia&#39;s speed, since IO operations are much less optimized than other types of operations in Julia. For example, every line in the <code>eachline</code> iterator needlessly allocates a string instead of mutating the same string or returning an <code>AbstractString</code> view into a buffer. And there is little to no good abstractions for tweaking file buffering in Julia.</p>
<p>I factor out the parsing from the core algorithm to more accurately asses the optimizations:</p>
<div class=juliacode ><pre><code class="plaintext hljs">parse(io::IO) = [Base.parse(Int, line, base=10) for line in eachline(io)]
solve(io::IO) = solve(parse(io))

function solve(v::AbstractVector{&lt;:Integer})
    zipdiff(a, b) = sum((@inbounds b[i] &gt; a[i] for i in eachindex(b)), init=0)
    return (zipdiff(v, @view v[2:end]), zipdiff(v, @view v[4:end]))
end</code></pre></div>
<p>Benchmarking only the <code>solve&#40;::AbstractVector&#41;</code> method by itself reveals that the optimization changed the minimum run time from 4.68 μs to 409 ns. A great improvement on the numerical part, but insignificant compared to the parse cost. In any case, I leave in the optimizations.</p>
<h2 id=the_easy_way ><a href="#the_easy_way" class=header-anchor >The easy way</a></h2>
<p>Setting up the whole environment and tests and such was a lot of work. Does it really have to be that complicated to code in Julia?</p>
<p>No&#33; A more typical Julia solution for day one could simply be a script with:</p>
<div class=juliacode ><pre><code class="plaintext hljs">function main(path)
    v = [parse(Int, line) for line in eachline(path)]
    println(sum(next &gt; prev for (prev, next) in zip(v, v[2:end])))
    println(sum(next &gt; prev for (prev, next) in zip(v, v[4:end])))
end

main(ARGS[1])</code></pre></div>
<p>Which runs in less than 1 second including startup time.</p>
<div class=page-foot >
  <div class=copyright >
    Jakob Nybo Nissen. Last modified: April 01, 2024. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>